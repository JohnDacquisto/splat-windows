/****************************************************************************\
*					SplatLib: Functions used by Splat						 *
*****************************************************************************/

#include "stdafx.h"
#include <math.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <Windows.h>
#include "SplatLib.h"
#include "itwom.h"
#include "fontdata.h"
#include "..\Common\Common.h"
#include "..\Common\Site.h"
#include "..\Common\version.h"
#include "..\Common\constants.h"


//| ------------------------------
//| 
//| FUNCTION: SetValueInDigitalElevationModelMask
//| 
//| OLD NAME: PutMask
//| 
//| NOTES: 
//|   Lines, text, markings, and coverage areas are stored in a
//|   mask that is combined with topology data when topographic
//|   maps are generated by SPLAT. This function sets and resets
//|   bits in the mask based on the latitude and longitude of the
//|   area pointed to.
//| 
//| ------------------------------
int
SetValueInDigitalElevationModelMask(
	double latitude,
	double longitude,
	int value,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	int	x, y, indx;
	bool found = false;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		digitalElevationModelWrapper->digitalElevationModel[indx].mask[x][y] = value;
		return ((int)digitalElevationModelWrapper->digitalElevationModel[indx].mask[x][y]);
	}
	else
	{
		return -1;
	}
}


//| ------------------------------
//| 
//| FUNCTION: SetOrValueInDigitalElevationModelMask
//| 
//| OLD NAME: OrMask
//| 
//| NOTES: 
//|   Lines, text, markings, and coverage areas are stored in a
//|   mask that is combined with topology data when topographic
//|   maps are generated by SPLAT. This function sets bits in
//|   the mask based on the latitude and longitude of the area
//|   pointed to.
//| 
//| ------------------------------
int
SetOrValueInDigitalElevationModelMask(
	double latitude,
	double longitude,
	int value,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	int	x, y, indx;
	bool found = false;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		digitalElevationModelWrapper->digitalElevationModel[indx].mask[x][y] |= value;
		return ((int)digitalElevationModelWrapper->digitalElevationModel[indx].mask[x][y]);
	}
	else
	{
		return -1;
	}
}


//| ------------------------------
//| 
//| FUNCTION: GetValueInDigitalElevationModelMask
//| 
//| OLD NAME: GetMask
//| 
//| NOTES: 
//|   This function returns the mask bits based on the latitude
//|   and longitude given.
//| 
//| ------------------------------
int
GetValueInDigitalElevationModelMask(
	double latitude,
	double longitude,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	return (SetOrValueInDigitalElevationModelMask(latitude, longitude, 0, digitalElevationModelWrapper));
}


//| ------------------------------
//| 
//| FUNCTION: SetValueInDigitalElevationModelSignal
//| 
//| OLD NAME: PutSignal
//| 
//| NOTES: 
//|   This function writes a signal level (0-255)
//|   at the specified location for later recall.
//| 
//| ------------------------------
int
SetValueInDigitalElevationModelSignal(
	double latitude,
	double longitude,
	unsigned char signal,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	int	x, y, indx;
	bool found = false;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		digitalElevationModelWrapper->digitalElevationModel[indx].signal[x][y] = signal;
		return (digitalElevationModelWrapper->digitalElevationModel[indx].signal[x][y]);
	}
	else
	{
		return 0;
	}
}


//| ------------------------------
//| 
//| FUNCTION: GetValueInDigitalElevationModelSignal
//| 
//| OLD NAME: GetSignal
//| 
//| NOTES: 
//|   This function reads the signal level (0-255) at the
//|   specified location that was previously written by the
//|   complimentary SetValueInDigitalElevationModelSignal() function.
//| 
//| ------------------------------
unsigned char
GetValueInDigitalElevationModelSignal(
	double latitude,
	double longitude,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	int	x, y, indx;
	bool found = false;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		return (digitalElevationModelWrapper->digitalElevationModel[indx].signal[x][y]);
	}
	else
	{
		return 0;
	}
}


//| ------------------------------
//| 
//| FUNCTION: GetSiteLocationElevation
//| 
//| OLD NAME: GetElevation
//| 
//| NOTES: 
//|   This function returns the elevation (in feet) of any location
//|   represented by the digital elevation model data in memory.
//|   Function returns LOCATION_NOT_IN_MEMORY for locations not found in memory.
//| 
//| ------------------------------
double
GetSiteLocationElevation(
	Site location,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	bool found = false;
	int	x, y, indx;
	double elevation;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(location.latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, location.longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		elevation = FEET_PER_METER * digitalElevationModelWrapper->digitalElevationModel[indx].data[x][y];
	}
	else
	{
		elevation = LOCATION_NOT_IN_MEMORY;
	}

	return elevation;
}


//| ------------------------------
//| 
//| FUNCTION: AddUserDefinedTerrainToDigitalElevationModelData
//| 
//| OLD NAME: AddElevation
//| 
//| NOTES: 
//|   This function adds a user-defined terrain feature
//|   (in meters AGL) to the digital elevation model data
//|   in memory. Does nothing and returns 0 for locations
//|   not found in memory.
//| 
//| ------------------------------
int
AddUserDefinedTerrainToDigitalElevationModelData(
	double latitude,
	double longitude,
	double height,
	DigitalElevationModelWrapper *digitalElevationModelWrapper)
{
	bool found = false;
	int	x, y, indx;

	for (indx = 0; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
	{
		x = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree)*(latitude - digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
		y = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference(digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

		if ((x >= 0) && (x <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y >= 0) && (y <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
		{
			found = true;
		}
		else
		{
			indx++;
		}
	}

	if (found)
	{
		digitalElevationModelWrapper->digitalElevationModel[indx].data[x][y] += (short)rint(height);
	}

	if (found)
	{
		return 1;
	}
	else 
	{
		return 0;
	}
}


//| ------------------------------
//| 
//| FUNCTION: ElevationAngleBetweenSites
//| 
//| OLD NAME: ElevationAngle
//| 
//| NOTES: 
//|   This function returns the angle of elevation (in degrees)
//|   of the destination as seen from the source location.
//|   A positive result represents an angle of elevation (uptilt),
//|   while a negative result represents an angle of depression
//|   (downtilt), as referenced to a normal to the center of
//|   the earth.
//| 
//| ------------------------------
double
ElevationAngleBetweenSites(
	Site source,
	Site destination,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	double sphereRadius)
{
	register double a, b, dx;

	a = GetSiteLocationElevation(destination, digitalElevationModelWrapper) + destination.altitude + sphereRadius;
	b = GetSiteLocationElevation(source, digitalElevationModelWrapper) + source.altitude + sphereRadius;

	dx = FEET_PER_MILE * GreatCircleDistanceBetweenSiteLocations(source, destination);

	// Apply the Law of Cosines

	return ((180.0*(acos(((b*b) + (dx*dx) - (a*a)) / (2.0*b*dx))) / PI) - 90.0);
}


//| ------------------------------
//| 
//| FUNCTION: GeneratePathBetweenSites
//| 
//| OLD NAME: ReadPath
//| 
//| NOTES: 
//|   This function generates a sequence of latitude and
//|   longitude positions between source and destination
//|   locations along a great circle path, and stores
//|   elevation and distance information for points
//|   along that path in the "path" structure.
//| 
//| ------------------------------
void
GeneratePathBetweenSites(
	Site source,
	Site destination,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path)
{
	int	c;
	double azimuth, distance, lat1, lon1, beta, den, num,
		lat2, lon2, total_distance, dx, dy, path_length,
		miles_per_sample, samples_per_radian = SAMPLES_PER_RADIAN_STANDARD;
	Site tempsite;

	lat1 = source.latitude * DEGREES_TO_RADIANS;
	lon1 = source.longitude * DEGREES_TO_RADIANS;

	lat2 = destination.latitude * DEGREES_TO_RADIANS;
	lon2 = destination.longitude * DEGREES_TO_RADIANS;

	if (((double)digitalElevationModelWrapper->demPixelsPerDegree) == (double)PIXELS_PER_DEGREE_STANDARD)
	{
		samples_per_radian = SAMPLES_PER_RADIAN_STANDARD;
	}

	if (((double)digitalElevationModelWrapper->demPixelsPerDegree) == (double)PIXELS_PER_DEGREE_HIGH_DEF)
	{
		samples_per_radian = SAMPLES_PER_RADIAN_HIGH_DEF;
	}

	azimuth = AzimuthAngleBetweenSites(source, destination) * DEGREES_TO_RADIANS;

	total_distance = GreatCircleDistanceBetweenSiteLocations(source, destination);

	if (total_distance > (30.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)))		// > 0.5 pixel distance
	{
		dx = samples_per_radian * acos(cos(lon1 - lon2));
		dy = samples_per_radian * acos(cos(lat1 - lat2));

		path_length = sqrt((dx*dx) + (dy*dy));		// Total number of samples

		miles_per_sample = total_distance / path_length;	// Miles per sample
	}
	else
	{
		c = 0;
		dx = 0.0;
		dy = 0.0;
		path_length = 0.0;
		miles_per_sample = 0.0;
		total_distance = 0.0;

		lat1 = lat1 / DEGREES_TO_RADIANS;
		lon1 = lon1 / DEGREES_TO_RADIANS;

		path->latitudes[c] = lat1;
		path->longitudes[c] = lon1;
		path->elevations[c] = GetSiteLocationElevation(source, digitalElevationModelWrapper);
		path->distances[c] = 0.0;
	}

	for (distance = 0.0, c = 0; (total_distance != 0.0) && (distance <= total_distance) && (c < path->pathArraySize); c++, distance = miles_per_sample * (double)c)
	{
		beta = distance / EARTH_RADIUS_MILES;
		lat2 = asin(sin(lat1)*cos(beta) + cos(azimuth)*sin(beta)*cos(lat1));
		num = cos(beta) - (sin(lat1)*sin(lat2));
		den = cos(lat1)*cos(lat2);

		if ((azimuth == 0.0) && (beta >(HALF_PI - lat1)))
		{
			lon2 = lon1 + PI;
		}
		else if ((azimuth == HALF_PI) && (beta > (HALF_PI + lat1)))
		{
			lon2 = lon1 + PI;
		}
		else if (fabs(num / den) > 1.0)
		{
			lon2 = lon1;
		}
		else
		{
			if ((PI - azimuth) >= 0.0)
			{
				lon2 = lon1 - ArcCosine(num, den);
			}
			else
			{
				lon2 = lon1 + ArcCosine(num, den);
			}
		}

		while (lon2 < 0.0)
		{
			lon2 += TWO_PI;
		}

		while (lon2 > TWO_PI)
		{
			lon2 -= TWO_PI;
		}

		lat2 = lat2 / DEGREES_TO_RADIANS;
		lon2 = lon2 / DEGREES_TO_RADIANS;

		path->latitudes[c] = lat2;
		path->longitudes[c] = lon2;
		tempsite.latitude = lat2;
		tempsite.longitude = lon2;
		path->elevations[c] = GetSiteLocationElevation(tempsite, digitalElevationModelWrapper);
		path->distances[c] = distance;
	}

	// Make sure exact destination point is recorded at path->length - 1

	if (c < path->pathArraySize)
	{
		path->latitudes[c] = destination.latitude;
		path->longitudes[c] = destination.longitude;
		path->elevations[c] = GetSiteLocationElevation(destination, digitalElevationModelWrapper);
		path->distances[c] = total_distance;
		c++;
	}

	if (c < path->pathArraySize)
	{
		path->pathLength = c;
	}
	else
	{
		path->pathLength = path->pathArraySize - 1;
	}
}


//| ------------------------------
//| 
//| FUNCTION: ObstructedElevationAngleBetweenSites
//| 
//| OLD NAME: ElevationAngle2
//| 
//| NOTES: 
//|   This function returns the angle of elevation (in degrees)
//|   of the destination as seen from the source location, UNLESS
//|   the path between the sites is obstructed, in which case, the
//|   elevation angle to the first obstruction is returned instead.
//|   "er" represents the earth radius.
//| 
//| ------------------------------
double
ObstructedElevationAngleBetweenSites(
	Site source,
	Site destination,
	double er,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path,
	double groundClutterHeight,
	double sphereRadius)
{
	int	x;
	bool block = false;
	double source_alt, destination_alt, cos_xmtr_angle,
		cos_test_angle, test_alt, elevation, distance,
		source_alt2, first_obstruction_angle = 0.0;

	Path *tempPath = new Path(path->pathArraySize);

	GeneratePathBetweenSites(source, destination, digitalElevationModelWrapper, tempPath);

	distance = FEET_PER_MILE * GreatCircleDistanceBetweenSiteLocations(source, destination);
	source_alt = er + source.altitude + GetSiteLocationElevation(source, digitalElevationModelWrapper);
	destination_alt = er + destination.altitude + GetSiteLocationElevation(destination, digitalElevationModelWrapper);
	source_alt2 = source_alt * source_alt;

	// Calculate the cosine of the elevation angle of the
	// destination (receiver) as seen by the source (transmitter).

	cos_xmtr_angle = ((source_alt2)+(distance*distance) - (destination_alt*destination_alt)) / (2.0*source_alt*distance);

	// Test all points in between source and destination locations to
	// see if the angle to a topographic feature generates a higher
	// elevation angle than that produced by the destination. Begin
	// at the source since we're interested in identifying the FIRST
	// obstruction along the path between source and destination.

	for (x = 2, block = false; (x < tempPath->pathLength) && (block == false); x++)
	{
		distance = FEET_PER_MILE * tempPath->distances[x];

		test_alt = sphereRadius + (tempPath->elevations[x] == 0.0 ? tempPath->elevations[x] : tempPath->elevations[x] + groundClutterHeight);

		cos_test_angle = ((source_alt2)+(distance*distance) - (test_alt*test_alt)) / (2.0*source_alt*distance);

		// Compare these two angles to determine if
		// an obstruction exists. Since we're comparing
		// the cosines of these angles rather than
		// the angles themselves, the sense of the
		// following "if" statement is reversed from
		// what it would be if the angles themselves
		// were compared.

		if (cos_xmtr_angle >= cos_test_angle)
		{
			block = true;
			first_obstruction_angle = ((acos(cos_test_angle)) / DEGREES_TO_RADIANS) - 90.0;
		}
	}

	if (block)
	{
		elevation = first_obstruction_angle;
	}
	else
	{
		elevation = ((acos(cos_xmtr_angle)) / DEGREES_TO_RADIANS) - 90.0;
	}

	return elevation;
}


//| ------------------------------
//| 
//| FUNCTION: AverageTerrainOverDistanceAtAzimuthFromSite
//| 
//| OLD NAME: AverageTerrain
//| 
//| NOTES: 
//|   This function returns the average terrain calculated in
//|   the direction of "azimuth" (degrees) between "start_distance"
//|   and "end_distance" (miles) from the source location. If
//|   the terrain is all water (non-critical error), LOCATION_NOT_IN_MEMORY is
//|   returned. If not enough SDF data has been loaded into
//|   memory to complete the survey (critical error), then
//|   LOCATION_CRITICAL_ERROR is returned.
//| 
//| ------------------------------
double
AverageTerrainOverDistanceAtAzimuthFromSite(
	Site source,
	double azimuthx,
	double start_distance,
	double end_distance,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path,
	double groundClutterHeight)
{
	int	c, samples, endpoint;
	double beta, lat1, lon1, lat2, lon2, num, den, azimuth, terrain = 0.0;
	Site destination;

	lat1 = source.latitude * DEGREES_TO_RADIANS;
	lon1 = source.longitude * DEGREES_TO_RADIANS;

	// Generate a path of elevations between the source
	// location and the remote location provided.

	beta = end_distance / EARTH_RADIUS_MILES;

	azimuth = DEGREES_TO_RADIANS * azimuthx;

	lat2 = asin(sin(lat1)*cos(beta) + cos(azimuth)*sin(beta)*cos(lat1));
	num = cos(beta) - (sin(lat1)*sin(lat2));
	den = cos(lat1)*cos(lat2);

	if ((azimuth == 0.0) && (beta > (HALF_PI - lat1)))
	{
		lon2 = lon1 + PI;
	}
	else if ((azimuth == HALF_PI) && (beta > (HALF_PI + lat1)))
	{
		lon2 = lon1 + PI;
	}
	else if (fabs(num / den) > 1.0)
	{
		lon2 = lon1;
	}
	else
	{
		if ((PI - azimuth) >= 0.0)
		{
			lon2 = lon1 - ArcCosine(num, den);
		}
		else
		{
			lon2 = lon1 + ArcCosine(num, den);
		}
	}

	while (lon2 < 0.0)
	{
		lon2 += TWO_PI;
	}

	while (lon2 > TWO_PI)
	{
		lon2 -= TWO_PI;
	}

	lat2 = lat2 / DEGREES_TO_RADIANS;
	lon2 = lon2 / DEGREES_TO_RADIANS;

	destination.latitude = lat2;
	destination.longitude = lon2;

	// If SDF data is missing for the endpoint of
	// the radial, then the average terrain cannot
	// be accurately calculated. Return LOCATION_CRITICAL_ERROR

	if (GetSiteLocationElevation(destination, digitalElevationModelWrapper) < (LOCATION_NOT_IN_MEMORY + 1))
	{
		return LOCATION_CRITICAL_ERROR;
	}
	else
	{
		GeneratePathBetweenSites(source, destination, digitalElevationModelWrapper, path);

		endpoint = path->pathLength;

		// Shrink the length of the radial if the
		// outermost portion is not over U.S. land.

		for (c = endpoint - 1; (c >= 0) && (path->elevations[c] == 0.0); c--);

		endpoint = c + 1;

		for (c = 0, samples = 0; c < endpoint; c++)
		{
			if (path->distances[c] >= start_distance)
			{
				terrain += (path->elevations[c] == 0.0 ? path->elevations[c] : path->elevations[c] + groundClutterHeight);
				samples++;
			}
		}

		if (samples == 0)
		{
			terrain = LOCATION_NOT_IN_MEMORY;  // No land
		}
		else
		{
			terrain = (terrain / (double)samples);
		}

		return terrain;
	}
}


//| ------------------------------
//| 
//| FUNCTION: AntennaHeightAboveAverageTerrain
//| 
//| OLD NAME: haat
//| 
//| NOTES: 
//|   This function returns the antenna's Height Above Average
//|   Terrain (HAAT) based on FCC Part 73.313(d). If a critical
//|   error occurs, such as a lack of SDF data to complete the
//|   survey, LOCATION_NOT_IN_MEMORY is returned.
//| 
//| ------------------------------
double
AntennaHeightAboveAverageTerrain(
	Site antenna,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path,
	double groundClutterHeight)
{
	int	azi, c;
	bool error = false;
	double terrain, avg_terrain, haat, sum = 0.0;

	// Calculate the average terrain between AVERAGE_TERRAIN_MIN_DISTANCE and AVERAGE_TERRAIN_MAX_DISTANCE 
	// from the antenna site at azimuths of 0, 45, 90, 135,
	// 180, 225, 270, and 315 degrees.

	for (c = 0, azi = 0; (azi <= 315) && (error == false); azi += 45)
	{
		terrain = AverageTerrainOverDistanceAtAzimuthFromSite(antenna, (double)azi, AVERAGE_TERRAIN_MIN_DISTANCE, AVERAGE_TERRAIN_MAX_DISTANCE, digitalElevationModelWrapper, path, groundClutterHeight);

		if (terrain < (LOCATION_CRITICAL_ERROR + 1))  // SDF data is missing
		{
			error = true;
		}

		if (terrain > (LOCATION_NOT_IN_MEMORY + 1))  // It's land, not water
		{
			sum += terrain;  // Sum of averages
			c++;
		}
	}

	if (error)
	{
		return LOCATION_NOT_IN_MEMORY;
	}
	else
	{
		avg_terrain = (sum / (double)c);
		haat = (antenna.altitude + GetSiteLocationElevation(antenna, digitalElevationModelWrapper)) - avg_terrain;
		return haat;
	}
}


//| ------------------------------
//| 
//| FUNCTION: PlaceTextAndMarkerDataInMaskArrayForMaps
//| 
//| OLD NAME: PlaceMarker
//| 
//| NOTES: 
//|   This function places text and marker data in the mask array
//|   for illustration on topographic maps generated by SPLAT.
//|   By default, SPLAT centers text information BELOW the marker,
//|   but may move it above, to the left, or to the right of the
//|   marker depending on how much room is available on the map,
//|   or depending on whether the area is already occupied by
//|   another marker or label. If no room or clear space is
//|   available on the map to place the marker and its associated
//|   text, then the marker and text are not written to the map.
//| 
//| ------------------------------
void
PlaceTextAndMarkerDataInMaskArrayForMaps(
	Site location,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	int	a, b, c, byte;
	bool ok2print;
	char occupied;
	double x, y, latitude, longitude, textx = 0.0, texty = 0.0, xmin, xmax,
		ymin, ymax, p1, p3, p6, p8, p12, p16, p24, label_length;

	xmin = (double)minimumLatitudeNorth;
	xmax = (double)maximumLatitudeNorth;
	ymin = (double)minimumLongitudeWest;
	ymax = (double)maximumLongitudeWest;
	latitude = location.latitude;
	longitude = location.longitude;

	if ((latitude < xmax) && (latitude >= xmin) && (LongitudeDifference(longitude, ymax) <= 0.0) && (LongitudeDifference(longitude, ymin) >= (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))))
	{
		p1 = 1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p3 = 3.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p6 = 6.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p8 = 8.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p12 = 12.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p16 = 16.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);
		p24 = 24.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree);

		ok2print = false;
		occupied = 0;

		// Is Marker Position Clear Of Text Or Other Markers?

		for (a = 0, x = latitude - p3; (x <= xmax) && (x >= xmin) && (a < 7); x += p1, a++)
		{
			for (b = 0, y = longitude - p3; (LongitudeDifference(y, ymax) <= 0.0) && (LongitudeDifference(y, ymin) >= (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))) && (b < 7); y += p1, b++)
			{
				occupied |= (GetValueInDigitalElevationModelMask(x, y, digitalElevationModelWrapper) & 2);
			}
		}

		if (occupied == 0)
		{
			// Determine Where Text Can Be Positioned

			// label_length=length in pixels.
			// Each character is 8 pixels wide.

			label_length = p1 * (double)(strlen(location.name) << 3);

			if ((LongitudeDifference(longitude + label_length, ymax) <= 0.0) && (LongitudeDifference(longitude - label_length, ymin) >= (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))))
			{
				// Default: Centered Text

				texty = longitude + label_length / 2.0;

				if ((latitude - p8) >= p16)
				{
					// Position Text Below The Marker

					textx = latitude - p8;

					x = textx;
					y = texty;

					// Is This Position Clear Of
					// Text Or Other Markers?

					for (a = 0, occupied = 0; a < 16; a++)
					{
						for (b = 0; b < (int)strlen(location.name); b++)
						{
							for (c = 0; c < 8; c++, y -= p1)
							{
								occupied |= (GetValueInDigitalElevationModelMask(x, y, digitalElevationModelWrapper) & 2);
							}
						}

						x -= p1;
						y = texty;
					}

					x = textx;
					y = texty;

					if (occupied == 0)
					{
						ok2print = true;
					}
				}
				else
				{
					// Position Text Above The Marker

					textx = latitude + p24;

					x = textx;
					y = texty;

					// Is This Position Clear Of
					// Text Or Other Markers?

					for (a = 0, occupied = 0; a < 16; a++)
					{
						for (b = 0; b < (int)strlen(location.name); b++)
						{
							for (c = 0; c < 8; c++, y -= p1)
							{
								occupied |= (GetValueInDigitalElevationModelMask(x, y, digitalElevationModelWrapper) & 2);
							}
						}

						x -= p1;
						y = texty;
					}

					x = textx;
					y = texty;

					if (occupied == 0)
					{
						ok2print = true;
					}
				}
			}

			if (ok2print == false)
			{
				if (LongitudeDifference(longitude - label_length, ymin) >= (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)))
				{
					// Position Text To The
					// Right Of The Marker

					textx = latitude + p6;
					texty = longitude - p12;

					x = textx;
					y = texty;

					// Is This Position Clear Of
					// Text Or Other Markers?

					for (a = 0, occupied = 0; a < 16; a++)
					{
						for (b = 0; b < (int)strlen(location.name); b++)
						{
							for (c = 0; c < 8; c++, y -= p1)
							{
								occupied |= (GetValueInDigitalElevationModelMask(x, y, digitalElevationModelWrapper) & 2);
							}
						}

						x -= p1;
						y = texty;
					}

					x = textx;
					y = texty;

					if (occupied == 0)
					{
						ok2print = true;
					}
				}
				else
				{
					// Position Text To The
					// Left Of The Marker

					textx = latitude + p6;
					texty = longitude + p8 + (label_length);

					x = textx;
					y = texty;

					// Is This Position Clear Of
					// Text Or Other Markers?

					for (a = 0, occupied = 0; a < 16; a++)
					{
						for (b = 0; b < (int)strlen(location.name); b++)
						{
							for (c = 0; c < 8; c++, y -= p1)
							{
								occupied |= (GetValueInDigitalElevationModelMask(x, y, digitalElevationModelWrapper) & 2);
							}
						}

						x -= p1;
						y = texty;
					}

					x = textx;
					y = texty;

					if (occupied == 0)
					{
						ok2print = true;
					}
				}
			}

			// textx and texty contain the latitude and longitude
			// coordinates that describe the placement of the text
			// on the map.

			if (ok2print)
			{
				// Draw Text

				x = textx;
				y = texty;

				for (a = 0; a < 16; a++)
				{
					for (b = 0; b<(int)strlen(location.name); b++)
					{
						byte = fontdata[16 * (location.name[b]) + a];

						for (c = 128; c > 0; c = c >> 1, y -= p1)
						{
							if (byte & c)
							{
								SetOrValueInDigitalElevationModelMask(x, y, 2, digitalElevationModelWrapper);
							}
						}
					}

					x -= p1;
					y = texty;
				}

				// Draw Square Marker Centered
				// On Location Specified

				for (a = 0, x = latitude - p3; (x <= xmax) && (x >= xmin) && (a < 7); x += p1, a++)
				{
					for (b = 0, y = longitude - p3; (LongitudeDifference(y, ymax) <= 0.0) && (LongitudeDifference(y, ymin) >= (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))) && (b < 7); y += p1, b++)
					{
						SetOrValueInDigitalElevationModelMask(x, y, 2, digitalElevationModelWrapper);
					}
				}
			}
		}
	}
}


//| ------------------------------
//| 
//| FUNCTION: LoadAndPlotCitiesAndSitesOnMaps
//| 
//| OLD NAME: LoadCities
//| 
//| NOTES: 
//|   This function reads SPLAT city/site files, and plots
//|   the locations and names of the cities and site locations
//|   read on topographic maps generated by SPLAT.
//| 
//| ------------------------------
void
LoadAndPlotCitiesAndSitesOnMaps(
	char *filename,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	int	x, y, z;
	char input[80], str[3][80];
	Site city_site;
	FILE *fd = NULL;
	errno_t err;

	err = fopen_s(&fd, filename, "r");

	if (fd != NULL)
	{
		fgets(input, 78, fd);

		fprintf(stdout, "\nReading \"%s\"... ", filename);
		fflush(stdout);

		while ((fd != NULL) && (feof(fd) == 0))
		{
			// Parse line for name, latitude, and longitude

			for (x = 0, y = 0, z = 0; (x < 78) && (input[x] != 0) && (z < 3); x++)
			{
				if ((input[x] != ',') && (y < 78))
				{
					str[z][y] = input[x];
					y++;
				}
				else
				{
					str[z][y] = 0;
					z++;
					y = 0;
				}
			}

			err = strncpy_s(city_site.name, _countof(city_site.name), str[0], 49);
			city_site.latitude = BearingStringToDecimalDegrees(str[1]);
			city_site.longitude = BearingStringToDecimalDegrees(str[2]);
			city_site.altitude = 0.0;

			if (city_site.longitude < 0.0)
			{
				city_site.longitude += 360.0;
			}

			PlaceTextAndMarkerDataInMaskArrayForMaps(city_site, digitalElevationModelWrapper, minimumLatitudeNorth, maximumLatitudeNorth,
				minimumLongitudeWest, maximumLongitudeWest);

			fgets(input, 78, fd);
		}

		fclose(fd);
		fprintf(stdout, "Done");
		fflush(stdout);
	}
	else
	{
		fprintf(stderr, "\n*** ERROR: \"%s\": not found", filename);
	}
}


//| ------------------------------
//| 
//| FUNCTION: ReadLongleyRiceParameterDataForSite
//| 
//| OLD NAME: ReadLRParm
//| 
//| NOTES: 
//|   This function reads ITM parameter data for the transmitter
//|   site. The file name is the same as the txsite, except the
//|   filename extension is .lrp. If the needed file is not found,
//|   then the .lrp file is read from the current working
//|   directory. Failure to load this file under a forced_read
//|   condition will result in the default parameters hard coded
//|   into this function to be used and written to a .lrp file for the txsite.
//| 
//| ------------------------------
char
ReadLongleyRiceParameterDataForSite(
	Site txsite,
	char forced_read,
	IrregularTerrainModelParameters *itmParameters,
	unsigned char *gotAntennaElevationAnglePattern,
	unsigned char *gotAntennaAzimuthAnglePattern,
	double fresnelZoneFrequency,
	double effectiveRadiatedPower,
	char *lrpFilePath)
{
	double din;
	bool return_value = false;
	char filename[255], LrString[80], *pointer = NULL;
	int	iin, ok = 0, x;
	FILE *fd = NULL, *outfile = NULL;
	errno_t err;

	// Default parameters

	itmParameters->dielectricRelativePermittivityConstant = 0.0;
	itmParameters->conductivitySiemensPerMeter = 0.0;
	itmParameters->atmosphericBendingConstant = 0.0;
	itmParameters->referenceFrequency = 0.0;
	itmParameters->radioClimate = 0;
	itmParameters->antennaPolarization = 0;
	itmParameters->fractionOfSituations = 0.0;
	itmParameters->fractionOfTime = 0.0;
	itmParameters->effectiveRadiatedPower = 0.0;

	// Generate .lrp filename from txsite filename.

	for (x = 0; (txsite.filename[x] != '.') && (txsite.filename[x] != 0) && (x < 250); x++)
	{
		filename[x] = txsite.filename[x];
	}

	filename[x] = '.';
	filename[x + 1] = 'l';
	filename[x + 2] = 'r';
	filename[x + 3] = 'p';
	filename[x + 4] = 0;

	err = fopen_s(&fd, filename, "r");

	if (fd == NULL)
	{
		// Load default "splat.lrp" file
		if (lrpFilePath != NULL)
		{
			ok = snprintf(filename, 253, "%s%s", lrpFilePath, "splat.lrp\0");
		}
		else
		{
			err = strncpy_s(filename, _countof(filename), "splat.lrp\0", 10);
		}
		err = fopen_s(&fd, filename, "r");
	}

	if (fd != NULL)
	{
		fgets(LrString, 80, fd);

		pointer = strchr(LrString, ';');

		if (pointer != NULL)
		{
			*pointer = 0;
		}

		ok = sscanf_s(LrString, "%lf", &din);

		if (ok != 0)
		{
			itmParameters->dielectricRelativePermittivityConstant = din;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%lf", &din);
		}

		if (ok != 0)
		{
			itmParameters->conductivitySiemensPerMeter = din;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%lf", &din);
		}

		if (ok != 0)
		{
			itmParameters->atmosphericBendingConstant = din;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%lf", &din);
		}

		if (ok != 0)
		{
			itmParameters->referenceFrequency = din;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%d", &iin);
		}

		if (ok != 0)
		{
			itmParameters->radioClimate = iin;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%d", &iin);
		}

		if (ok != 0)
		{
			itmParameters->antennaPolarization = iin;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%lf", &din);
		}

		if (ok != 0)
		{
			itmParameters->fractionOfSituations = din;

			fgets(LrString, 80, fd);

			pointer = strchr(LrString, ';');

			if (pointer != NULL)
			{
				*pointer = 0;
			}

			ok = sscanf_s(LrString, "%lf", &din);
		}

		if (ok != 0)
		{
			itmParameters->fractionOfTime = din;
			din = 0.0;
			return_value = true;

			if (fgets(LrString, 80, fd) != NULL)
			{
				pointer = strchr(LrString, ';');

				if (pointer != NULL)
				{
					*pointer = 0;
				}

				if (sscanf_s(LrString, "%lf", &din))
				{
					itmParameters->effectiveRadiatedPower = din;
				}

				// ERP in SPLAT is referenced to 1 Watt
				// into a dipole (0 dBd). If ERP is
				// expressed in dBm (referenced to a
				// 0 dBi radiator), convert dBm in EIRP
				// to ERP.

				if ((strstr(LrString, "dBm") != NULL) || (strstr(LrString, "dbm") != NULL))
				{
					itmParameters->effectiveRadiatedPower = (pow(10.0, (itmParameters->effectiveRadiatedPower - DBW_TO_DBM - DIPOLE_TO_ISOTROPIC_ANTENNA) / 10.0));
				}
			}
		}

		fclose(fd);

		if (effectiveRadiatedPower != -1.0)
		{
			itmParameters->effectiveRadiatedPower = effectiveRadiatedPower;
		}

		if ((fresnelZoneFrequency >= MINIMUM_FREQUENCY) && (fresnelZoneFrequency <= MAXIMUM_FREQUENCY))
		{
			itmParameters->referenceFrequency = fresnelZoneFrequency;
		}

		if (ok != 0)
		{
			LoadAntennaAzimuthElevationPatternFiles(filename, itmParameters, gotAntennaElevationAnglePattern, gotAntennaAzimuthAnglePattern);
		}
	}

	if ((fd == NULL) && forced_read)
	{
		// Assign some default parameters
		// for use in this run.

		itmParameters->dielectricRelativePermittivityConstant = 15.0;
		itmParameters->conductivitySiemensPerMeter = 0.005;
		itmParameters->atmosphericBendingConstant = 301.0;
		itmParameters->referenceFrequency = 300.0;
		itmParameters->radioClimate = 5;
		itmParameters->antennaPolarization = 0;
		itmParameters->fractionOfSituations = 0.50;
		itmParameters->fractionOfTime = 0.50;
		itmParameters->effectiveRadiatedPower = 0.0;

		// Write them to a .lrp file.

		err = fopen_s(&outfile, filename, "w");

		fprintf(outfile, "%.3f\t; Earth Dielectric Constant (Relative permittivity)\n", itmParameters->dielectricRelativePermittivityConstant);
		fprintf(outfile, "%.3f\t; Earth Conductivity (Siemens per meter)\n", itmParameters->conductivitySiemensPerMeter);
		fprintf(outfile, "%.3f\t; Atmospheric Bending Constant (N-Units)\n", itmParameters->atmosphericBendingConstant);
		fprintf(outfile, "%.3f\t; Frequency in MHz (20 MHz to 20 GHz)\n", itmParameters->referenceFrequency);
		fprintf(outfile, "%d\t; Radio Climate\n", itmParameters->radioClimate);
		fprintf(outfile, "%d\t; Polarization (0 = Horizontal, 1 = Vertical)\n", itmParameters->antennaPolarization);
		fprintf(outfile, "%.2f\t; Fraction of Situations\n", itmParameters->fractionOfSituations);
		fprintf(outfile, "%.2f\t; Fraction of Time\n", itmParameters->fractionOfTime);
		fprintf(outfile, "%.2f\t; Transmitter Effective Radiated Power in Watts or dBm (optional)\n", itmParameters->effectiveRadiatedPower);
		fprintf(outfile, "\nPlease consult SPLAT documentation for the meaning and use of this data.\n");

		fclose(outfile);

		return_value = true;

		fprintf(stderr, "\n\n%c*** There were problems reading your \"%s\" file ***\nSPLAT will create and use an .lrp file with default data.\n", 7, filename);
	}
	else if (forced_read == 0)
	{
		return_value = false;
	}

	if (forced_read && ((fd == NULL) || (ok == 0)))
	{
		itmParameters->dielectricRelativePermittivityConstant = 15.0;
		itmParameters->conductivitySiemensPerMeter = 0.005;
		itmParameters->atmosphericBendingConstant = 301.0;
		itmParameters->referenceFrequency = 300.0;
		itmParameters->radioClimate = 5;
		itmParameters->antennaPolarization = 0;
		itmParameters->fractionOfSituations = 0.50;
		itmParameters->fractionOfTime = 0.50;
		itmParameters->effectiveRadiatedPower = 0.0;

		fprintf(stderr, "Default parameters have been assumed for this analysis.\n");

		return_value = true;
	}

	if (return_value)
	{
		return 1;
	}
	else 
	{
		return 0;
	}
}


//| ------------------------------
//| 
//| FUNCTION: PlotLineOfSightCoverageFromSiteAtAltitude
//| 
//| OLD NAME: PlotLOSMap
//| 
//| NOTES: 
//|   This function performs a 360 degree sweep around the
//|   transmitter site (source location), and plots the
//|   line-of-sight coverage of the transmitter on the SPLAT
//|   generated topographic map based on a receiver located
//|   at the specified altitude (in feet AGL). Results
//|   are stored in memory, and written out in the form
//|   of a topographic map when the WritePortablePixMapLineOfSightCoverageFile() function
//|   is later invoked.
//| 
//| ------------------------------
void
PlotLineOfSightCoverageFromSiteAtAltitude(
	Site source,
	double altitude,
	char *plo_filename,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path,
	unsigned char useMetricUnits,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest,
	double groundClutterHeight,
	double sphereRadius)
{
	int x, y, z, count;
	Site edge;
	unsigned char symbol[4];
	double latitude, longitude, minwest, maxnorth, th;
	static unsigned char mask_value = 1;
	FILE *fd = NULL;
	errno_t err;

	symbol[0] = '.';
	symbol[1] = 'o';
	symbol[2] = 'O';
	symbol[3] = 'o';

	count = 0;

	fprintf(stdout, "\nComputing line-of-sight coverage of \"%s\" with an RX antenna\nat %.2f %s AGL", source.name, (useMetricUnits ? altitude * METERS_PER_FOOT : altitude), (useMetricUnits ? "meters" : "feet"));

	if (groundClutterHeight > 0.0)
	{
		fprintf(stdout, " and %.2f %s of ground clutter", (useMetricUnits ? groundClutterHeight * METERS_PER_FOOT : groundClutterHeight), (useMetricUnits ? "meters" : "feet"));
	}

	fprintf(stdout, "...\n\n 0%c to  25%c ", 37, 37);
	fflush(stdout);

	if (plo_filename[0] != 0)
	{
		err = fopen_s(&fd, plo_filename, "wb");
	}

	if (fd != NULL)
	{
		// Write header information to output file
		fprintf(fd, "%d, %d\t; max_west, min_west\n%d, %d\t; max_north, min_north\n\n", maximumLongitudeWest, minimumLongitudeWest, maximumLatitudeNorth, minimumLatitudeNorth);
		fprintf(fd, "Latitude, Longitude\n");
	}

	// th=pixels/degree divided by 64 loops per
	// progress indicator symbol (.oOo) printed.

	th = ((double)digitalElevationModelWrapper->demPixelsPerDegree) / 64.0;

	z = (int)(th * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));

	minwest = (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) + (double)minimumLongitudeWest;
	maxnorth = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));

	for (longitude = minwest, x = 0, y = 0; LongitudeDifference(longitude, (double)maximumLongitudeWest) <= 0.0; y++, longitude = (minwest + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		if (longitude >= 360.0)
		{
			longitude -= 360.0;
		}

		edge.latitude = maximumLatitudeNorth;
		edge.longitude = longitude;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotLineOfSightCoverageBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, groundClutterHeight, sphereRadius);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n25%c to  50%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ToDouble(maximumLatitudeNorth - minimumLatitudeNorth));

	for (latitude = maxnorth, x = 0, y = 0; latitude >= (double)minimumLatitudeNorth; y++, latitude = maxnorth - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y))
	{
		edge.latitude = latitude;
		edge.longitude = minimumLongitudeWest;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotLineOfSightCoverageBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, groundClutterHeight, sphereRadius);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n50%c to  75%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));

	for (longitude = minwest, x = 0, y = 0; LongitudeDifference(longitude, (double)maximumLongitudeWest) <= 0.0; y++, longitude = (minwest + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		if (longitude >= 360.0)
		{
			longitude -= 360.0;
		}

		edge.latitude = minimumLatitudeNorth;
		edge.longitude = longitude;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotLineOfSightCoverageBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, groundClutterHeight, sphereRadius);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n75%c to 100%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ToDouble(maximumLatitudeNorth - minimumLatitudeNorth));

	for (latitude = (double)minimumLatitudeNorth, x = 0, y = 0; latitude < (double)maximumLatitudeNorth; y++, latitude = ((double)minimumLatitudeNorth + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		edge.latitude = latitude;
		edge.longitude = maximumLongitudeWest;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotLineOfSightCoverageBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, groundClutterHeight, sphereRadius);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	if (fd != NULL)
	{
		fclose(fd);
	}

	fprintf(stdout, "\nDone\n");
	fflush(stdout);

	// Assign next mask value

	switch (mask_value)
	{
	case 1:
		mask_value = 8;
		break;

	case 8:
		mask_value = 16;
		break;

	case 16:
		mask_value = 32;
	}
}


//| ------------------------------
//| 
//| FUNCTION: PlotAttenuationFromSiteAtAltitude
//| 
//| OLD NAME: PlotLRMap
//| 
//| NOTES: 
//|   This function performs a 360 degree sweep around the
//|   transmitter site (source location), and plots the
//|   Irregular Terrain Model attenuation on the SPLAT
//|   generated topographic map based on a receiver located
//|   at the specified altitude (in feet AGL). Results
//|   are stored in memory, and written out in the form
//|   of a topographic map when the WritePortablePixMapAttenuationFile() or
//|   WritePortablePixMapSignalStrengthFile() functions are later invoked.
//| 
//| ------------------------------
void
PlotAttenuationFromSiteAtAltitude(
	Site source,
	double altitude,
	char *plo_filename,
	DigitalElevationModelWrapper *digitalElevationModelWrapper,
	Path *path,
	IrregularTerrainModelParameters *itmParameters,
	double *pathElevation,
	char useOldLongleyRiceModel,
	unsigned char plotSignalPowerLevelContours,
	unsigned char gotAntennaElevationAnglePattern,
	unsigned char useMetricUnits,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest,
	double maximumAnalysisDistance,
	double groundClutterHeight)
{
	int x, y, z, count;
	Site edge;
	double latitude, longitude, minwest, maxnorth, th;
	unsigned char symbol[4];
	static unsigned char mask_value = 1;
	FILE *fd = NULL;
	errno_t err;

	minwest = (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) + (double)minimumLongitudeWest;
	maxnorth = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));

	symbol[0] = '.';
	symbol[1] = 'o';
	symbol[2] = 'O';
	symbol[3] = 'o';

	count = 0;

	if (useOldLongleyRiceModel)
	{
		fprintf(stdout, "\nComputing ITM ");
	}
	else
	{
		fprintf(stdout, "\nComputing ITWOM ");
	}

	if (itmParameters->effectiveRadiatedPower == 0.0)
	{
		fprintf(stdout, "path loss");
	}
	else
	{
		if (plotSignalPowerLevelContours != 0)
		{
			fprintf(stdout, "signal power level");
		}
		else
		{
			fprintf(stdout, "field strength");
		}
	}

	fprintf(stdout, " contours of \"%s\"\nout to a radius of %.2f %s with an RX antenna at %.2f %s AGL", source.name, (useMetricUnits ? maximumAnalysisDistance * KM_PER_MILE : maximumAnalysisDistance), (useMetricUnits ? "kilometers" : "miles"), (useMetricUnits ? altitude * METERS_PER_FOOT : altitude), (useMetricUnits ? "meters" : "feet"));

	if (groundClutterHeight > 0.0)
	{
		fprintf(stdout, "\nand %.2f %s of ground clutter", (useMetricUnits ? groundClutterHeight * METERS_PER_FOOT : groundClutterHeight), (useMetricUnits ? "meters" : "feet"));
	}

	fprintf(stdout, "...\n\n 0%c to  25%c ", 37, 37);
	fflush(stdout);

	if (plo_filename[0] != 0)
	{
		err = fopen_s(&fd, plo_filename, "wb");
	}

	if (fd != NULL)
	{
		// Write header information to output file
		fprintf(fd, "%d, %d\t; max_west, min_west\n%d, %d\t; max_north, min_north\n\n", maximumLongitudeWest, minimumLongitudeWest, maximumLatitudeNorth, minimumLatitudeNorth);
		fprintf(fd, "Latitude, Longitude, AzimuthAngle, ElevationAngle, ");
		if (itmParameters->effectiveRadiatedPower == 0.0)
		{
			fprintf(fd, "PathLoss\n");
		}
		else
		{
			if (plotSignalPowerLevelContours != 0)
			{
				fprintf(fd, "dBm\n");
			}
			else
			{
				fprintf(fd, "FieldStrength\n");
			}
		}
	}

	// th=pixels/degree divided by 64 loops per
	// progress indicator symbol (.oOo) printed.

	th = ((double)digitalElevationModelWrapper->demPixelsPerDegree) / 64.0;

	z = (int)(th * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));

	for (longitude = minwest, x = 0, y = 0; LongitudeDifference(longitude, (double)maximumLongitudeWest) <= 0.0; y++, longitude = (minwest + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		if (longitude >= 360.0)
		{
			longitude -= 360.0;
		}

		edge.latitude = maximumLatitudeNorth;
		edge.longitude = longitude;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotPathLossBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, itmParameters, pathElevation, useOldLongleyRiceModel,
			plotSignalPowerLevelContours, gotAntennaElevationAnglePattern, maximumAnalysisDistance, groundClutterHeight);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n25%c to  50%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ToDouble(maximumLatitudeNorth - minimumLatitudeNorth));

	for (latitude = maxnorth, x = 0, y = 0; latitude >= (double)minimumLatitudeNorth; y++, latitude = (maxnorth - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		edge.latitude = latitude;
		edge.longitude = minimumLongitudeWest;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotPathLossBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, itmParameters, pathElevation, useOldLongleyRiceModel,
			plotSignalPowerLevelContours, gotAntennaElevationAnglePattern, maximumAnalysisDistance, groundClutterHeight);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n50%c to  75%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));

	for (longitude = minwest, x = 0, y = 0; LongitudeDifference(longitude, (double)maximumLongitudeWest) <= 0.0; y++, longitude = (minwest + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		if (longitude >= 360.0)
		{
			longitude -= 360.0;
		}
		edge.latitude = minimumLatitudeNorth;
		edge.longitude = longitude;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotPathLossBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, itmParameters, pathElevation, useOldLongleyRiceModel,
			plotSignalPowerLevelContours, gotAntennaElevationAnglePattern, maximumAnalysisDistance, groundClutterHeight);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	count = 0;
	fprintf(stdout, "\n75%c to 100%c ", 37, 37);
	fflush(stdout);

	z = (int)(th * ToDouble(maximumLatitudeNorth - minimumLatitudeNorth));

	for (latitude = (double)minimumLatitudeNorth, x = 0, y = 0; latitude < (double)maximumLatitudeNorth; y++, latitude = ((double)minimumLatitudeNorth + ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree))*(double)y)))
	{
		edge.latitude = latitude;
		edge.longitude = maximumLongitudeWest;
		edge.altitude = (float)altitude;

		AnalyzeAndPlotPathLossBetweenSites(source, edge, mask_value, fd, digitalElevationModelWrapper, path, itmParameters, pathElevation, useOldLongleyRiceModel,
			plotSignalPowerLevelContours, gotAntennaElevationAnglePattern, maximumAnalysisDistance, groundClutterHeight);
		count++;

		if (count == z)
		{
			fprintf(stdout, "%c", symbol[x]);
			fflush(stdout);
			count = 0;

			if (x == 3)
			{
				x = 0;
			}
			else
			{
				x++;
			}
		}
	}

	if (fd != NULL)
	{
		fclose(fd);
	}

	fprintf(stdout, "\nDone\n");
	fflush(stdout);

	if (mask_value < 30)
	{
		mask_value++;
	}
}
