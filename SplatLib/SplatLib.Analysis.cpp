/****************************************************************************\
*					SplatLib.Analysis: SPLAT Analysis						 *
*****************************************************************************/

#include "stdafx.h"
#include <math.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <Windows.h>
#include "SplatLib.h"
#include "itwom.h"
#include "fontdata.h"
#include "..\Common\Common.h"
#include "..\Common\Site.h"
#include "..\Common\version.h"
#include "..\Common\constants.h"


//| ------------------------------
//| 
//| FUNCTION: AnalyzeAndPlotLineOfSightCoverageBetweenSites
//| 
//| OLD NAME: PlotPath
//| 
//| NOTES: 
//|   This function analyzes the path between the source and
//|   destination locations. It determines which points along
//|   the path have line-of-sight visibility to the source.
//|   Points along with path having line-of-sight visibility
//|   to the source at an AGL altitude equal to that of the
//|   destination location are stored by setting bit 1 in the
//|   mask[][] array, which are displayed in green when PPM
//|   maps are later generated by SPLAT.
//| 
//| ------------------------------
void
AnalyzeAndPlotLineOfSightCoverageBetweenSites(
	Site source,
	Site destination,
	char mask_value,
	FILE* fd,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	double groundClutterHeight,
	double sphereRadius)
{
	bool block;
	int x, y;
	register double cos_xmtr_angle, cos_test_angle, test_alt;
	double distance, rx_alt, tx_alt;

	GeneratePathBetweenSites(source, destination, digitalElevationModelWrapper, path);

	for (y = 0; y < path->pathLength; y++)
	{
		// Test this point only if it hasn't been already
		// tested and found to be free of obstructions.

		if ((GetValueInDigitalElevationModelMask(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper) & mask_value) == 0)
		{
			distance = FEET_PER_MILE * path->distances[y];
			tx_alt = sphereRadius + source.altitude + path->elevations[0];
			rx_alt = sphereRadius + destination.altitude + path->elevations[y];

			// Calculate the cosine of the elevation of the
			// transmitter as seen at the temp rx point.

			cos_xmtr_angle = ((rx_alt * rx_alt) + (distance * distance) - (tx_alt * tx_alt)) / (2.0 * rx_alt * distance);

			for (x = y, block = false; (x >= 0) && (block == false); x--)
			{
				distance = FEET_PER_MILE * (path->distances[y] - path->distances[x]);
				test_alt = sphereRadius + (path->elevations[x] == 0.0 ? path->elevations[x] : path->elevations[x] + groundClutterHeight);

				cos_test_angle = ((rx_alt * rx_alt) + (distance * distance) - (test_alt * test_alt)) / (2.0 * rx_alt * distance);

				// Compare these two angles to determine if
				// an obstruction exists. Since we're comparing
				// the cosines of these angles rather than
				// the angles themselves, the following "if"
				// statement is reversed from what it would
				// be if the actual angles were compared.

				if (cos_xmtr_angle >= cos_test_angle)
				{
					block = true;
				}
			}

			if (block == false)
			{
				SetOrValueInDigitalElevationModelMask(path->latitudes[y], path->longitudes[y], mask_value, digitalElevationModelWrapper);
			}

			if (fd != NULL)
			{
				fprintf(fd, "%.7f, %.7f", path->latitudes[y], path->longitudes[y]);
				if (block)
				{
					fprintf(fd, " (Obstruction)");
				}
				fprintf(fd, "\n");
			}
		}
	}
}


//| ------------------------------
//| 
//| FUNCTION: AnalyzeAndPlotPathLossBetweenSites
//| 
//| OLD NAME: PlotLRPath
//| 
//| NOTES: 
//|   This function plots the RF path loss between source and
//|   destination points based on the ITWOM propagation model,
//|   taking into account antenna pattern data, if available.
//| 
//| ------------------------------
void
AnalyzeAndPlotPathLossBetweenSites(
	Site source,
	Site destination,
	unsigned char mask_value,
	FILE* fd,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	IrregularTerrainModelParameters* itmParameters,
	double* pathElevation,
	char useOldLongleyRiceModel,
	unsigned char plotSignalPowerLevelContours,
	unsigned char gotAntennaElevationAnglePattern,
	double maximumAnalysisDistance,
	double groundClutterHeight)
{
	int	x, y, ifs, ofs, errnum;
	bool block = false;
	char strmode[100];
	double loss, azimuth, pattern = 0.0, xmtr_alt,
		dest_alt, xmtr_alt2, dest_alt2, cos_rcvr_angle,
		cos_test_angle = 0.0, test_alt, elevation = 0.0,
		distance = 0.0, four_thirds_earth, rxp, dBm,
		field_strength = 0.0;
	Site temp;

	GeneratePathBetweenSites(source, destination, digitalElevationModelWrapper, path);

	four_thirds_earth = FOUR_THIRDS * EARTH_RADIUS_FEET;

	// Copy elevations plus clutter along path into the pathElevation[] array.

	for (x = 1; x < path->pathLength - 1; x++)
	{
		pathElevation[x + 2] = (path->elevations[x] == 0.0 ? path->elevations[x] * METERS_PER_FOOT : (groundClutterHeight + path->elevations[x]) * METERS_PER_FOOT);
	}

	// Copy ending points without clutter

	pathElevation[2] = path->elevations[0] * METERS_PER_FOOT;
	pathElevation[path->pathLength + 1] = path->elevations[path->pathLength - 1] * METERS_PER_FOOT;

	// Since the only energy the propagation model considers
	// reaching the destination is based on what is scattered
	// or deflected from the first obstruction along the path,
	// we first need to find the location and elevation angle
	// of that first obstruction (if it exists). This is done
	// using a 4/3rds Earth radius to match the radius used by
	// the irregular terrain propagation model. This information
	// is required for properly integrating the antenna's elevation
	// pattern into the calculation for overall path loss.

	for (y = 2; (y < (path->pathLength - 1)) && (path->distances[y] <= maximumAnalysisDistance); y++)
	{
		// Process this point only if it
		// has not already been processed.

		if ((GetValueInDigitalElevationModelMask(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper) & 248) != (mask_value << 3))
		{
			distance = FEET_PER_MILE * path->distances[y];
			xmtr_alt = four_thirds_earth + source.altitude + path->elevations[0];
			dest_alt = four_thirds_earth + destination.altitude + path->elevations[y];
			dest_alt2 = dest_alt * dest_alt;
			xmtr_alt2 = xmtr_alt * xmtr_alt;

			// Calculate the cosine of the elevation of
			// the receiver as seen by the transmitter.

			cos_rcvr_angle = (xmtr_alt2 + (distance * distance) - dest_alt2) / (2.0 * xmtr_alt * distance);

			if (cos_rcvr_angle > 1.0)
			{
				cos_rcvr_angle = 1.0;
			}

			if (cos_rcvr_angle < -1.0)
			{
				cos_rcvr_angle = -1.0;
			}

			if (gotAntennaElevationAnglePattern || (fd != NULL))
			{
				// Determine the elevation angle to the first obstruction
				// along the path IF elevation pattern data is available
				// or an output (.ano) file has been designated.

				for (x = 2, block = false; (x < y) && (block == false); x++)
				{
					distance = FEET_PER_MILE * path->distances[x];

					test_alt = four_thirds_earth + (path->elevations[x] == 0.0 ? path->elevations[x] : path->elevations[x] + groundClutterHeight);

					// Calculate the cosine of the elevation
					// angle of the terrain (test point)
					// as seen by the transmitter.

					cos_test_angle = (xmtr_alt2 + (distance * distance) - (test_alt * test_alt)) / (2.0 * xmtr_alt * distance);

					if (cos_test_angle > 1.0)
					{
						cos_test_angle = 1.0;
					}

					if (cos_test_angle < -1.0)
					{
						cos_test_angle = -1.0;
					}

					// Compare these two angles to determine if
					// an obstruction exists. Since we're comparing
					// the cosines of these angles rather than
					// the angles themselves, the sense of the
					// following "if" statement is reversed from
					// what it would be if the angles themselves
					// were compared.

					if (cos_rcvr_angle >= cos_test_angle)
					{
						block = true;
					}
				}

				if (block)
				{
					elevation = ((acos(cos_test_angle)) / DEGREES_TO_RADIANS) - 90.0;
				}
				else
				{
					elevation = ((acos(cos_rcvr_angle)) / DEGREES_TO_RADIANS) - 90.0;
				}
			}

			// Determine attenuation for each point along
			// the path using ITWOM's PointToPointCalculation mode
			// starting at y=2 (number_of_points = 1), the
			// shortest distance terrain can play a role in
			// path loss.

			pathElevation[0] = ToDouble(y - 1);  // (number of points - 1)

			// Distance between elevation samples

			pathElevation[1] = METERS_PER_MILE * (path->distances[y] - path->distances[y - 1]);

			if (useOldLongleyRiceModel)
			{
				PointToPointCalculationLegacy(pathElevation, (source.altitude * METERS_PER_FOOT),
					(destination.altitude * METERS_PER_FOOT), itmParameters->dielectricRelativePermittivityConstant,
					itmParameters->conductivitySiemensPerMeter, itmParameters->atmosphericBendingConstant, itmParameters->referenceFrequency,
					itmParameters->radioClimate, itmParameters->antennaPolarization, itmParameters->fractionOfSituations, itmParameters->fractionOfTime, loss,
					strmode, 100, errnum);
			}
			else
			{
				PointToPointCalculation(pathElevation, (source.altitude * METERS_PER_FOOT),
					(destination.altitude * METERS_PER_FOOT), itmParameters->dielectricRelativePermittivityConstant,
					itmParameters->conductivitySiemensPerMeter, itmParameters->atmosphericBendingConstant, itmParameters->referenceFrequency,
					itmParameters->radioClimate, itmParameters->antennaPolarization, itmParameters->fractionOfSituations, itmParameters->fractionOfTime, loss,
					strmode, 100, errnum);
			}

			temp.latitude = path->latitudes[y];
			temp.longitude = path->longitudes[y];

			azimuth = AzimuthAngleBetweenSites(source, temp);

			if (fd != NULL)
			{
				fprintf(fd, "%.7f, %.7f, %.3f, %.3f, ", path->latitudes[y], path->longitudes[y], azimuth, elevation);
			}

			// If ERP == 0, write path loss to alphanumeric
			// output file. Otherwise, write field strength
			// or received power level (below), as appropriate.

			if ((fd != NULL) && (itmParameters->effectiveRadiatedPower == 0.0))
			{
				fprintf(fd, "%.2f", loss);
			}

			// Integrate the antenna's radiation
			// pattern into the overall path loss.

			x = (int)rint(10.0 * (10.0 - elevation));

			if ((x >= 0) && (x <= 1000))
			{
				azimuth = rint(azimuth);

				pattern = (double)itmParameters->antennaRadiationPattern[(int)azimuth][x];

				if (pattern != 0.0)
				{
					pattern = 20.0 * log10(pattern);
					loss -= pattern;
				}
			}

			if (itmParameters->effectiveRadiatedPower != 0.0)
			{
				if (plotSignalPowerLevelContours != 0)
				{
					// dBm is based on EIRP (ERP + DIPOLE_TO_ISOTROPIC_ANTENNA)

					rxp = itmParameters->effectiveRadiatedPower / pow(10.0, (loss - DIPOLE_TO_ISOTROPIC_ANTENNA) / 10.0);

					dBm = 10.0 * log10(rxp * 1000.0);

					if (fd != NULL)
					{
						fprintf(fd, "%.3f", dBm);
					}

					// Scale roughly between 0 and 255

					ifs = 200 + (int)rint(dBm);

					if (ifs < 0)
					{
						ifs = 0;
					}

					if (ifs > 255)
					{
						ifs = 255;
					}

					ofs = GetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper);

					if (ofs > ifs)
					{
						ifs = ofs;
					}

					SetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], (unsigned char)ifs, digitalElevationModelWrapper);
				}
				else
				{
					field_strength = (FIELD_STRENGTH_MAGIC_NUMBER + (20.0 * log10(itmParameters->referenceFrequency)) - loss) + (10.0 * log10(itmParameters->effectiveRadiatedPower / 1000.0));

					ifs = 100 + (int)rint(field_strength);

					if (ifs < 0)
					{
						ifs = 0;
					}

					if (ifs > 255)
					{
						ifs = 255;
					}

					ofs = GetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper);

					if (ofs > ifs)
					{
						ifs = ofs;
					}

					SetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], (unsigned char)ifs, digitalElevationModelWrapper);

					if (fd != NULL)
					{
						fprintf(fd, "%.3f", field_strength);
					}
				}
			}
			else
			{
				if (loss > 255)
				{
					ifs = 255;
				}
				else
				{
					ifs = (int)rint(loss);
				}

				ofs = GetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper);

				if ((ofs < ifs) && (ofs != 0))
				{
					ifs = ofs;
				}

				SetValueInDigitalElevationModelSignal(path->latitudes[y], path->longitudes[y], (unsigned char)ifs, digitalElevationModelWrapper);
			}

			if (fd != NULL)
			{
				if (block)
				{
					fprintf(fd, " (Obstruction)");
				}
				fprintf(fd, "\n");
			}

			// Mark this point as having been analyzed

			SetValueInDigitalElevationModelMask(path->latitudes[y], path->longitudes[y], (GetValueInDigitalElevationModelMask(path->latitudes[y], path->longitudes[y], digitalElevationModelWrapper) & 7) + (mask_value << 3), digitalElevationModelWrapper);
		}
	}
}


//| ------------------------------
//| 
//| FUNCTION: PerformObstructionAnalysisBetweenSites
//| 
//| OLD NAME: ObstructionAnalysis
//| 
//| NOTES: 
//|   Perform an obstruction analysis along the
//|   path between receiver and transmitter.
//| 
//| ------------------------------
void
PerformObstructionAnalysisBetweenSites(
	Site xmtr,
	Site rcvr,
	double f,
	FILE* outfile,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	unsigned char useMetricUnits,
	double groundClutterHeight,
	double fresnelZoneClearanceRatio,
	double sphereRadius)
{
	int	x;
	Site site_x;
	double h_r, h_t, h_x, h_r_orig, cos_tx_angle, cos_test_angle,
		cos_tx_angle_f1, cos_tx_angle_fpt6, d_tx, d_x,
		h_r_f1, h_r_fpt6, h_f, h_los, lambda = 0.0;
	char ObsString[255], string_fpt6[255], string_f1[255];

	GeneratePathBetweenSites(xmtr, rcvr, digitalElevationModelWrapper, path);
	h_r = GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) + rcvr.altitude + sphereRadius;
	h_r_f1 = h_r;
	h_r_fpt6 = h_r;
	h_r_orig = h_r;
	h_t = GetSiteLocationElevation(xmtr, digitalElevationModelWrapper) + xmtr.altitude + sphereRadius;
	d_tx = FEET_PER_MILE * GreatCircleDistanceBetweenSiteLocations(rcvr, xmtr);
	cos_tx_angle = ((h_r * h_r) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r * d_tx);
	cos_tx_angle_f1 = cos_tx_angle;
	cos_tx_angle_fpt6 = cos_tx_angle;

	if (f)
	{
		lambda = SPEED_OF_LIGHT_FEET_PER_SECOND / (f * 1e6);
	}

	if (groundClutterHeight > 0.0)
	{
		fprintf(outfile, "Terrain has been raised by");

		if (useMetricUnits)
		{
			fprintf(outfile, " %.2f meters", METERS_PER_FOOT * groundClutterHeight);
		}
		else
		{
			fprintf(outfile, " %.2f feet", groundClutterHeight);
		}

		fprintf(outfile, " to account for ground clutter.\n\n");
	}

	// At each point along the path calculate the cosine
	// of a sort of "inverse elevation angle" at the receiver.
	// From the antenna, 0 deg. looks at the ground, and 90 deg.
	// is parallel to the ground.
	//
	// Start at the receiver. If this is the lowest antenna,
	// then terrain obstructions will be nearest to it. Plus,
	// that's the way SPLAT's original los() did it.
	//
	// Calculate cosines only. That's sufficient to compare
	// angles and it saves the extra computational burden of
	// acos(). However, note the inverted comparison: if
	// acos(A) > acos(B), then B > A.

	for (x = path->pathLength - 1; x > 0; x--)
	{
		site_x.latitude = path->latitudes[x];
		site_x.longitude = path->longitudes[x];
		site_x.altitude = 0.0;

		h_x = GetSiteLocationElevation(site_x, digitalElevationModelWrapper) + sphereRadius + groundClutterHeight;
		d_x = FEET_PER_MILE * GreatCircleDistanceBetweenSiteLocations(rcvr, site_x);

		// Deal with the LOS path first.

		cos_test_angle = ((h_r * h_r) + (d_x * d_x) - (h_x * h_x)) / (2.0 * h_r * d_x);

		if (cos_tx_angle > cos_test_angle)
		{
			if (h_r == h_r_orig)
			{
				fprintf(outfile, "Between %s and %s, %s detected obstructions at:\n\n", rcvr.name, xmtr.name, APP_NAME);
			}

			if (site_x.latitude >= 0.0)
			{
				if (useMetricUnits)
				{
					fprintf(outfile, "   %8.4f N,%9.4f W, %5.2f kilometers, %6.2f meters AMSL\n", site_x.latitude, site_x.longitude, KM_PER_MILE * (d_x / FEET_PER_MILE), METERS_PER_FOOT * (h_x - sphereRadius));
				}
				else
				{
					fprintf(outfile, "   %8.4f N,%9.4f W, %5.2f miles, %6.2f feet AMSL\n", site_x.latitude, site_x.longitude, d_x / FEET_PER_MILE, h_x - sphereRadius);
				}
			}
			else
			{
				if (useMetricUnits)
				{
					fprintf(outfile, "   %8.4f S,%9.4f W, %5.2f kilometers, %6.2f meters AMSL\n", -site_x.latitude, site_x.longitude, KM_PER_MILE * (d_x / FEET_PER_MILE), METERS_PER_FOOT * (h_x - sphereRadius));
				}
				else
				{
					fprintf(outfile, "   %8.4f S,%9.4f W, %5.2f miles, %6.2f feet AMSL\n", -site_x.latitude, site_x.longitude, d_x / FEET_PER_MILE, h_x - sphereRadius);
				}
			}
		}

		while (cos_tx_angle > cos_test_angle)
		{
			h_r += 1;
			cos_test_angle = ((h_r * h_r) + (d_x * d_x) - (h_x * h_x)) / (2.0 * h_r * d_x);
			cos_tx_angle = ((h_r * h_r) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r * d_tx);
		}

		if (f)
		{
			// Now clear the first Fresnel zone,

			cos_tx_angle_f1 = ((h_r_f1 * h_r_f1) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r_f1 * d_tx);
			h_los = sqrt(h_r_f1 * h_r_f1 + d_x * d_x - 2 * h_r_f1 * d_x * cos_tx_angle_f1);
			h_f = h_los - sqrt(lambda * d_x * (d_tx - d_x) / d_tx);

			while (h_f < h_x)
			{
				h_r_f1 += 1;
				cos_tx_angle_f1 = ((h_r_f1 * h_r_f1) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r_f1 * d_tx);
				h_los = sqrt(h_r_f1 * h_r_f1 + d_x * d_x - 2 * h_r_f1 * d_x * cos_tx_angle_f1);
				h_f = h_los - sqrt(lambda * d_x * (d_tx - d_x) / d_tx);
			}

			// and clear the 60% F1 zone.

			cos_tx_angle_fpt6 = ((h_r_fpt6 * h_r_fpt6) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r_fpt6 * d_tx);
			h_los = sqrt(h_r_fpt6 * h_r_fpt6 + d_x * d_x - 2 * h_r_fpt6 * d_x * cos_tx_angle_fpt6);
			h_f = h_los - fresnelZoneClearanceRatio * sqrt(lambda * d_x * (d_tx - d_x) / d_tx);

			while (h_f < h_x)
			{
				h_r_fpt6 += 1;
				cos_tx_angle_fpt6 = ((h_r_fpt6 * h_r_fpt6) + (d_tx * d_tx) - (h_t * h_t)) / (2.0 * h_r_fpt6 * d_tx);
				h_los = sqrt(h_r_fpt6 * h_r_fpt6 + d_x * d_x - 2 * h_r_fpt6 * d_x * cos_tx_angle_fpt6);
				h_f = h_los - fresnelZoneClearanceRatio * sqrt(lambda * d_x * (d_tx - d_x) / d_tx);
			}
		}
	}

	if (h_r > h_r_orig)
	{
		if (useMetricUnits)
		{
			snprintf(ObsString, 150, "\nAntenna at %s must be raised to at least %.2f meters AGL\nto clear all obstructions detected by %s.\n", rcvr.name, METERS_PER_FOOT * (h_r - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius), APP_NAME);
		}
		else
		{
			snprintf(ObsString, 150, "\nAntenna at %s must be raised to at least %.2f feet AGL\nto clear all obstructions detected by %s.\n", rcvr.name, h_r - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius, APP_NAME);
		}
	}
	else
	{
		snprintf(ObsString, 150, "\nNo obstructions to LOS path due to terrain were detected by %s\n", APP_NAME);
	}

	if (f)
	{
		if (h_r_fpt6 > h_r_orig)
		{
			if (useMetricUnits)
			{
				snprintf(string_fpt6, 150, "\nAntenna at %s must be raised to at least %.2f meters AGL\nto clear %.0f%c of the first Fresnel zone.\n", rcvr.name, METERS_PER_FOOT * (h_r_fpt6 - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius), fresnelZoneClearanceRatio * 100.0, 37);
			}
			else
			{
				snprintf(string_fpt6, 150, "\nAntenna at %s must be raised to at least %.2f feet AGL\nto clear %.0f%c of the first Fresnel zone.\n", rcvr.name, h_r_fpt6 - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius, fresnelZoneClearanceRatio * 100.0, 37);
			}
		}
		else
		{
			snprintf(string_fpt6, 150, "\n%.0f%c of the first Fresnel zone is clear.\n", fresnelZoneClearanceRatio * 100.0, 37);
		}

		if (h_r_f1 > h_r_orig)
		{
			if (useMetricUnits)
			{
				snprintf(string_f1, 150, "\nAntenna at %s must be raised to at least %.2f meters AGL\nto clear the first Fresnel zone.\n", rcvr.name, METERS_PER_FOOT * (h_r_f1 - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius));
			}
			else
			{
				snprintf(string_f1, 150, "\nAntenna at %s must be raised to at least %.2f feet AGL\nto clear the first Fresnel zone.\n", rcvr.name, h_r_f1 - GetSiteLocationElevation(rcvr, digitalElevationModelWrapper) - sphereRadius);
			}
		}
		else
		{
			snprintf(string_f1, 150, "\nThe first Fresnel zone is clear.\n");
		}
	}

	fprintf(outfile, "%s", ObsString);

	if (f)
	{
		fprintf(outfile, "%s", string_f1);
		fprintf(outfile, "%s", string_fpt6);
	}
}
