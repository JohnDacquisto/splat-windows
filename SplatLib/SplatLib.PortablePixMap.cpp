/****************************************************************************\
*					SplatLib.PortablePixMap: PPM Output Files				 *
*****************************************************************************/

#include "stdafx.h"
#include <math.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <Windows.h>
#include "SplatLib.h"
#include "itwom.h"
#include "fontdata.h"
#include "..\Common\Common.h"
#include "..\Common\Site.h"
#include "..\Common\version.h"
#include "..\Common\constants.h"


//| ------------------------------
//| 
//| FUNCTION: WritePortablePixMapLineOfSightCoverageFile
//| 
//| OLD NAME: WritePPM
//| 
//| NOTES: 
//|   This function generates a topographic map in Portable Pix Map
//|   (PPM) format based on logarithmically scaled topology data,
//|   as well as the content of flags held in the mask[][] array.
//|   The image created is rotated counter-clockwise 90 degrees
//|   from its representation in digitalElevationModel[][] so that north points
//|   up and east points right in the image generated.
//| 
//| ------------------------------
void
WritePortablePixMapLineOfSightCoverageFile(
	char* filename,
	unsigned char geo,
	unsigned char kml,
	unsigned char ngs,
	Site* xmtr,
	unsigned char txsites,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	int maximumElevation,
	int minimumElevation,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	char mapfile[255], geofile[255], kmlfile[255];
	bool found;
	unsigned char mask;
	unsigned width, height, terrain;
	int indx, x, y, x0 = 0, y0 = 0;
	double latitude, longitude, conversion, one_over_gamma,
		north, south, east, west, minwest;
	FILE* fd;
	errno_t err;

	one_over_gamma = 1.0 / GAMMA;
	conversion = 255.0 / pow(ToDouble(maximumElevation - minimumElevation), one_over_gamma);
	width = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));
	height = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLatitudeNorth - minimumLatitudeNorth)));
	if (filename[0] == 0)
	{
		err = strncpy_s(filename, 255, xmtr[0].filename, 254);
		filename[strlen(filename) - 4] = 0;  // Remove .qth
	}
	y = (int)strlen(filename);
	if (y > 4)
	{
		if ((filename[y - 1] == 'm') && (filename[y - 2] == 'p') && (filename[y - 3] == 'p') && (filename[y - 4] == '.'))
		{
			y -= 4;
		}
	}
	for (x = 0; x < y; x++)
	{
		mapfile[x] = filename[x];
		geofile[x] = filename[x];
		kmlfile[x] = filename[x];
	}
	mapfile[x] = '.';
	geofile[x] = '.';
	kmlfile[x] = '.';
	mapfile[x + 1] = 'p';
	geofile[x + 1] = 'g';
	kmlfile[x + 1] = 'k';
	mapfile[x + 2] = 'p';
	geofile[x + 2] = 'e';
	kmlfile[x + 2] = 'm';
	mapfile[x + 3] = 'm';
	geofile[x + 3] = 'o';
	kmlfile[x + 3] = 'l';
	mapfile[x + 4] = 0;
	geofile[x + 4] = 0;
	kmlfile[x + 4] = 0;
	minwest = ((double)minimumLongitudeWest) + (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (minwest > 360.0)
	{
		minwest -= 360.0;
	}
	north = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	south = (double)minimumLatitudeNorth;
	east = (minwest < 180.0 ? -minwest : 360.0 - minimumLongitudeWest);
	west = (double)(maximumLongitudeWest < 180 ? -maximumLongitudeWest : 360 - maximumLongitudeWest);
	if ((kml == 0) && geo)
	{
		err = fopen_s(&fd, geofile, "wb");
		fprintf(fd, "FILENAME\t%s\n", mapfile);
		fprintf(fd, "#\t\tX\tY\tLong\t\tLat\n");
		fprintf(fd, "TIEPOINT\t0\t0\t%.3f\t\t%.3f\n", west, north);
		fprintf(fd, "TIEPOINT\t%u\t%u\t%.3f\t\t%.3f\n", width - 1, height - 1, east, south);
		fprintf(fd, "IMAGESIZE\t%u\t%u\n", width, height);
		fprintf(fd, "#\n# Auto Generated by %s v%s\n#\n", APP_NAME, VERSION_HEADER);
		fclose(fd);
	}
	if (kml && (geo == 0))
	{
		err = fopen_s(&fd, kmlfile, "wb");
		fprintf(fd, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(fd, "<kml xmlns=\"http://earth.google.com/kml/2.1\">\n");
		fprintf(fd, "  <Folder>\n");
		fprintf(fd, "   <name>%s</name>\n", APP_NAME);
		fprintf(fd, "     <description>Line-of-Sight Contour</description>\n");
		fprintf(fd, "       <GroundOverlay>\n");
		fprintf(fd, "         <name>%s Line-of-Sight Contour</name>\n", APP_NAME);
		fprintf(fd, "           <description>SPLAT Coverage</description>\n");
		fprintf(fd, "		<Icon>\n");
		fprintf(fd, "              <href>%s</href>\n", mapfile);
		fprintf(fd, "		</Icon>\n");
		//fprintf(fd,"            <opacity>128</opacity>\n");
		fprintf(fd, "            <LatLonBox>\n");
		fprintf(fd, "               <north>%.5f</north>\n", north);
		fprintf(fd, "               <south>%.5f</south>\n", south);
		fprintf(fd, "               <east>%.5f</east>\n", east);
		fprintf(fd, "               <west>%.5f</west>\n", west);
		fprintf(fd, "               <rotation>0.0</rotation>\n");
		fprintf(fd, "            </LatLonBox>\n");
		fprintf(fd, "       </GroundOverlay>\n");
		for (x = 0; x < txsites; x++)
		{
			fprintf(fd, "     <Placemark>\n");
			fprintf(fd, "       <name>%s</name>\n", xmtr[x].name);
			fprintf(fd, "       <visibility>1</visibility>\n");
			fprintf(fd, "       <Style>\n");
			fprintf(fd, "       <IconStyle>\n");
			fprintf(fd, "        <Icon>\n");
			fprintf(fd, "          <href>root://icons/palette-5.png</href>\n");
			fprintf(fd, "          <x>224</x>\n");
			fprintf(fd, "          <y>224</y>\n");
			fprintf(fd, "          <w>32</w>\n");
			fprintf(fd, "          <h>32</h>\n");
			fprintf(fd, "        </Icon>\n");
			fprintf(fd, "       </IconStyle>\n");
			fprintf(fd, "       </Style>\n");
			fprintf(fd, "      <Point>\n");
			fprintf(fd, "        <extrude>1</extrude>\n");
			fprintf(fd, "        <altitudeMode>relativeToGround</altitudeMode>\n");
			fprintf(fd, "        <coordinates>%f,%f,%f</coordinates>\n", (xmtr[x].longitude < 180.0 ? -xmtr[x].longitude : 360.0 - xmtr[x].longitude), xmtr[x].latitude, xmtr[x].altitude);
			fprintf(fd, "      </Point>\n");
			fprintf(fd, "     </Placemark>\n");
		}
		fprintf(fd, "  </Folder>\n");
		fprintf(fd, "</kml>\n");
		fclose(fd);
	}
	err = fopen_s(&fd, mapfile, "wb");
	fprintf(fd, "P6\n%u %u\n255\n", width, height);
	fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height);
	fflush(stdout);
	for (y = 0, latitude = north; y < (int)height; y++, latitude = (north - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)y)))
	{
		for (x = 0, longitude = maximumLongitudeWest; x < (int)width; x++, longitude = ((double)maximumLongitudeWest - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)x)))
		{
			if (longitude < 0.0)
			{
				longitude += 360.0;
			}
			for (indx = 0, found = false; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
			{
				x0 = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * (latitude - (double)digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
				y0 = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference((double)digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));
				if ((x0 >= 0) && (x0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y0 >= 0) && (y0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
				{
					found = true;
				}
				else
				{
					indx++;
				}
			}
			if (found)
			{
				mask = digitalElevationModelWrapper->digitalElevationModel[indx].mask[x0][y0];
				if (mask & 2)		// Text Labels: Red
				{
					fprintf(fd, "%c%c%c", 255, 0, 0);
				}
				else if (mask & 4)	// County Boundaries: Light Cyan
				{
					fprintf(fd, "%c%c%c", 128, 128, 255);
				}
				else
				{
					switch (mask & 57)
					{
					case 1:		// TX1: Green
						fprintf(fd, "%c%c%c", 0, 255, 0);
						break;
					case 8:		// TX2: Cyan
						fprintf(fd, "%c%c%c", 0, 255, 255);
						break;
					case 9:		// TX1 + TX2: Yellow
						fprintf(fd, "%c%c%c", 255, 255, 0);
						break;
					case 16:	// TX3: Medium Violet
						fprintf(fd, "%c%c%c", 147, 112, 219);
						break;
					case 17:	// TX1 + TX3: Pink
						fprintf(fd, "%c%c%c", 255, 192, 203);
						break;
					case 24:	// TX2 + TX3: Orange
						fprintf(fd, "%c%c%c", 255, 165, 0);
						break;
					case 25:	// TX1 + TX2 + TX3: Dark Green
						fprintf(fd, "%c%c%c", 0, 100, 0);
						break;
					case 32:	// TX4: Sienna 1
						fprintf(fd, "%c%c%c", 255, 130, 71);
						break;
					case 33:	// TX1 + TX4: Green Yellow
						fprintf(fd, "%c%c%c", 173, 255, 47);
						break;
					case 40:	// TX2 + TX4: Dark Sea Green 1
						fprintf(fd, "%c%c%c", 193, 255, 193);
						break;
					case 41:	// TX1 + TX2 + TX4: Blanched Almond
						fprintf(fd, "%c%c%c", 255, 235, 205);
						break;
					case 48:	// TX3 + TX4: Dark Turquoise
						fprintf(fd, "%c%c%c", 0, 206, 209);
						break;
					case 49:	// TX1 + TX3 + TX4: Medium Spring Green
						fprintf(fd, "%c%c%c", 0, 250, 154);
						break;
					case 56:	// TX2 + TX3 + TX4: Tan
						fprintf(fd, "%c%c%c", 210, 180, 140);
						break;
					case 57:	// TX1 + TX2 + TX3 + TX4: Gold2
						fprintf(fd, "%c%c%c", 238, 201, 0);
						break;
					default:
						if (ngs)	// No terrain
						{
							fprintf(fd, "%c%c%c", 255, 255, 255);
						}
						else
						{
							if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)	// Sea-level: Medium Blue
							{
								fprintf(fd, "%c%c%c", 0, 0, 170);
							}
							else	// Elevation: Greyscale
							{
								terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
								fprintf(fd, "%c%c%c", terrain, terrain, terrain);
							}
						}
					}
				}
			}
			else	// We should never get here, but if we do, display the region as black
			{
				fprintf(fd, "%c%c%c", 0, 0, 0);
			}
		}
	}
	fclose(fd);
	fprintf(stdout, "Done\n");
	fflush(stdout);
}


//| ------------------------------
//| 
//| FUNCTION: WritePortablePixMapAttenuationFile
//| 
//| OLD NAME: WritePPMLR
//| 
//| NOTES: 
//|   This function generates a topographic map in Portable Pix Map
//|   (PPM) format based on the content of flags held in the mask[][]
//|   array (only). The image created is rotated counter-clockwise
//|   90 degrees from its representation in digitalElevationModel[][] so that north
//|   points up and east points right in the image generated.
//| 
//| ------------------------------
void
WritePortablePixMapAttenuationFile(
	char* filename,
	unsigned char geo,
	unsigned char kml,
	unsigned char ngs,
	Site* xmtr,
	unsigned char txsites,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	ColorRegion* region,
	unsigned char displaySmoothContourLevels,
	int contourDisplayThreshold,
	int maximumElevation,
	int minimumElevation,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	char mapfile[255], geofile[255], kmlfile[255], ckfile[255];
	unsigned width, height, red, green, blue, terrain = 0;
	bool found, cityorcounty;
	unsigned char mask;
	int indx, x, y, z, colorwidth, x0, y0, loss, level,
		hundreds, tens, units, match;
	double latitude, longitude, conversion, one_over_gamma,
		north, south, east, west, minwest;
	FILE* fd;
	errno_t err;

	one_over_gamma = 1.0 / GAMMA;
	conversion = 255.0 / pow(ToDouble(maximumElevation - minimumElevation), one_over_gamma);
	width = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));
	height = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLatitudeNorth - minimumLatitudeNorth)));
	LoadSplatLossColorsForSite(xmtr[0], region);
	if (filename[0] == 0)
	{
		err = strncpy_s(filename, 255, xmtr[0].filename, 254);
		filename[strlen(filename) - 4] = 0;  // Remove .qth
	}
	y = (int)strlen(filename);
	if (y > 240)
	{
		y = 240;
	}
	if (y > 4)
	{
		if ((filename[y - 1] == 'm') && (filename[y - 2] == 'p') && (filename[y - 3] == 'p') && (filename[y - 4] == '.'))
		{
			y -= 4;
		}
	}
	for (x = 0; x < y; x++)
	{
		mapfile[x] = filename[x];
		geofile[x] = filename[x];
		kmlfile[x] = filename[x];
		ckfile[x] = filename[x];
	}
	mapfile[x] = '.';
	geofile[x] = '.';
	kmlfile[x] = '.';
	mapfile[x + 1] = 'p';
	geofile[x + 1] = 'g';
	kmlfile[x + 1] = 'k';
	mapfile[x + 2] = 'p';
	geofile[x + 2] = 'e';
	kmlfile[x + 2] = 'm';
	mapfile[x + 3] = 'm';
	geofile[x + 3] = 'o';
	kmlfile[x + 3] = 'l';
	mapfile[x + 4] = 0;
	geofile[x + 4] = 0;
	kmlfile[x + 4] = 0;
	ckfile[x] = '-';
	ckfile[x + 1] = 'c';
	ckfile[x + 2] = 'k';
	ckfile[x + 3] = '.';
	ckfile[x + 4] = 'p';
	ckfile[x + 5] = 'p';
	ckfile[x + 6] = 'm';
	ckfile[x + 7] = 0;
	minwest = ((double)minimumLongitudeWest) + (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (minwest > 360.0)
	{
		minwest -= 360.0;
	}
	north = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (kml || geo)
	{
		south = (double)minimumLatitudeNorth;	// No bottom legend
	}
	else
	{
		south = (double)minimumLatitudeNorth - (30.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)); // 30 pixels for bottom legend
	}
	east = (minwest < 180.0 ? -minwest : 360.0 - minimumLongitudeWest);
	west = (double)(maximumLongitudeWest < 180 ? -maximumLongitudeWest : 360 - maximumLongitudeWest);
	if ((kml == 0) && geo)
	{
		err = fopen_s(&fd, geofile, "wb");
		fprintf(fd, "FILENAME\t%s\n", mapfile);
		fprintf(fd, "#\t\tX\tY\tLong\t\tLat\n");
		fprintf(fd, "TIEPOINT\t0\t0\t%.3f\t\t%.3f\n", west, north);
		fprintf(fd, "TIEPOINT\t%u\t%u\t%.3f\t\t%.3f\n", width - 1, height - 1, east, south);
		fprintf(fd, "IMAGESIZE\t%u\t%u\n", width, height);
		fprintf(fd, "#\n# Auto Generated by %s v%s\n#\n", APP_NAME, VERSION_HEADER);
		fclose(fd);
	}
	if (kml && (geo == 0))
	{
		err = fopen_s(&fd, kmlfile, "wb");
		fprintf(fd, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(fd, "<kml xmlns=\"http://earth.google.com/kml/2.1\">\n");
		fprintf(fd, "<!-- Generated by %s Version %s -->\n", APP_NAME, VERSION_HEADER);
		fprintf(fd, "  <Folder>\n");
		fprintf(fd, "   <name>%s</name>\n", APP_NAME);
		fprintf(fd, "     <description>%s Transmitter Path Loss Overlay</description>\n", xmtr[0].name);
		fprintf(fd, "       <GroundOverlay>\n");
		fprintf(fd, "         <name>SPLAT Path Loss Overlay</name>\n");
		fprintf(fd, "           <description>SPLAT Coverage</description>\n");
		fprintf(fd, "		<Icon>\n");
		fprintf(fd, "              <href>%s</href>\n", mapfile);
		fprintf(fd, "		</Icon>\n");
		//fprintf(fd,"            <opacity>128</opacity>\n");
		fprintf(fd, "            <LatLonBox>\n");
		fprintf(fd, "               <north>%.5f</north>\n", north);
		fprintf(fd, "               <south>%.5f</south>\n", south);
		fprintf(fd, "               <east>%.5f</east>\n", east);
		fprintf(fd, "               <west>%.5f</west>\n", west);
		fprintf(fd, "               <rotation>0.0</rotation>\n");
		fprintf(fd, "            </LatLonBox>\n");
		fprintf(fd, "       </GroundOverlay>\n");
		fprintf(fd, "       <ScreenOverlay>\n");
		fprintf(fd, "          <name>Color Key</name>\n");
		fprintf(fd, "		<description>Contour Color Key</description>\n");
		fprintf(fd, "          <Icon>\n");
		fprintf(fd, "            <href>%s</href>\n", ckfile);
		fprintf(fd, "          </Icon>\n");
		fprintf(fd, "          <overlayXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <screenXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <rotationXY x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <size x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "       </ScreenOverlay>\n");
		for (x = 0; x < txsites; x++)
		{
			fprintf(fd, "     <Placemark>\n");
			fprintf(fd, "       <name>%s</name>\n", xmtr[x].name);
			fprintf(fd, "       <visibility>1</visibility>\n");
			fprintf(fd, "       <Style>\n");
			fprintf(fd, "       <IconStyle>\n");
			fprintf(fd, "        <Icon>\n");
			fprintf(fd, "          <href>root://icons/palette-5.png</href>\n");
			fprintf(fd, "          <x>224</x>\n");
			fprintf(fd, "          <y>224</y>\n");
			fprintf(fd, "          <w>32</w>\n");
			fprintf(fd, "          <h>32</h>\n");
			fprintf(fd, "        </Icon>\n");
			fprintf(fd, "       </IconStyle>\n");
			fprintf(fd, "       </Style>\n");
			fprintf(fd, "      <Point>\n");
			fprintf(fd, "        <extrude>1</extrude>\n");
			fprintf(fd, "        <altitudeMode>relativeToGround</altitudeMode>\n");
			fprintf(fd, "        <coordinates>%f,%f,%f</coordinates>\n", (xmtr[x].longitude < 180.0 ? -xmtr[x].longitude : 360.0 - xmtr[x].longitude), xmtr[x].latitude, xmtr[x].altitude);
			fprintf(fd, "      </Point>\n");
			fprintf(fd, "     </Placemark>\n");
		}
		fprintf(fd, "  </Folder>\n");
		fprintf(fd, "</kml>\n");
		fclose(fd);
	}
	err = fopen_s(&fd, mapfile, "wb");
	if (kml || geo)	// No bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height);
	}
	else			// Allow space for bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height + 30);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height + 30);
	}
	fflush(stdout);
	for (y = 0, latitude = north; y < (int)height; y++, latitude = (north - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)y)))
	{
		for (x = 0, longitude = maximumLongitudeWest; x < (int)width; x++, longitude = (maximumLongitudeWest - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)x)))
		{
			if (longitude < 0.0)
			{
				longitude += 360.0;
			}
			for (indx = 0, found = false; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
			{
				x0 = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * (latitude - (double)digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
				y0 = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference((double)digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));
				if ((x0 >= 0) && (x0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y0 >= 0) && (y0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
				{
					found = true;
				}
				else
				{
					indx++;
				}
			}
			if (found)
			{
				mask = digitalElevationModelWrapper->digitalElevationModel[indx].mask[x0][y0];
				loss = digitalElevationModelWrapper->digitalElevationModel[indx].signal[x0][y0];
				cityorcounty = false;
				match = 255;
				red = 0;
				green = 0;
				blue = 0;
				if (loss <= region->level[0])
				{
					match = 0;
				}
				else
				{
					for (z = 1; (z < region->levels) && (match == 255); z++)
					{
						if ((loss >= region->level[z - 1]) && (loss < region->level[z]))
						{
							match = z;
						}
					}
				}
				if (match < region->levels)
				{
					if (displaySmoothContourLevels && (match > 0))
					{
						red = (unsigned)LinearInterpolation(region->color[match - 1][0], region->color[match][0], region->level[match - 1], region->level[match], loss);
						green = (unsigned)LinearInterpolation(region->color[match - 1][1], region->color[match][1], region->level[match - 1], region->level[match], loss);
						blue = (unsigned)LinearInterpolation(region->color[match - 1][2], region->color[match][2], region->level[match - 1], region->level[match], loss);
					}
					else
					{
						red = region->color[match][0];
						green = region->color[match][1];
						blue = region->color[match][2];
					}
				}
				if (mask & 2)		// Text Labels: Red or otherwise
				{
					if ((red >= 180) && (green <= 75) && (blue <= 75) && (loss != 0))
					{
						fprintf(fd, "%c%c%c", 255 ^ red, 255 ^ green, 255 ^ blue);
					}
					else
					{
						fprintf(fd, "%c%c%c", 255, 0, 0);
					}
					cityorcounty = true;
				}
				else if (mask & 4)	// County Boundaries: Black
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
					cityorcounty = true;
				}
				if (cityorcounty == false)
				{
					if ((loss == 0) || ((contourDisplayThreshold != 0) && (loss > abs(contourDisplayThreshold))))
					{
						if (ngs)	// No terrain
						{
							fprintf(fd, "%c%c%c", 255, 255, 255);
						}
						else		// Display land or sea elevation
						{
							if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)
							{
								fprintf(fd, "%c%c%c", 0, 0, 170);
							}
							else
							{
								terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
								fprintf(fd, "%c%c%c", terrain, terrain, terrain);
							}
						}
					}
					else
					{
						if ((red != 0) || (green != 0) || (blue != 0))	// Plot path loss in color
						{
							fprintf(fd, "%c%c%c", red, green, blue);
						}
						else
						{
							if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)	// terrain / sea-level
							{
								fprintf(fd, "%c%c%c", 0, 0, 170);
							}
							else	// Elevation: Greyscale
							{
								terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
								fprintf(fd, "%c%c%c", terrain, terrain, terrain);
							}
						}
					}
				}
			}
			else	// We should never get here, but if we do, display the region as black
			{
				fprintf(fd, "%c%c%c", 0, 0, 0);
			}
		}
	}
	if ((kml == 0) && (geo == 0))	// Display legend along bottom of image if not generating .kml or .geo output.
	{
		colorwidth = (int)rint((float)width / (float)region->levels);
		for (y0 = 0; y0 < 30; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = x0 / colorwidth;
				x = x0 % colorwidth;
				level = region->level[indx];
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if ((y0 >= 8) && (y0 <= 23))
				{
					if (hundreds > 0)
					{
						if ((x >= 11) && (x <= 18))
						{
							if (fontdata[16 * (hundreds + '0') + (y0 - 8)] & (128 >> (x - 11)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if ((x >= 19) && (x <= 26))
						{
							if (fontdata[16 * (tens + '0') + (y0 - 8)] & (128 >> (x - 19)))
							{
								indx = 255;
							}
						}
					}
					if ((x >= 27) && (x <= 34))
					{
						if (fontdata[16 * (units + '0') + (y0 - 8)] & (128 >> (x - 27)))
						{
							indx = 255;
						}
					}
					if ((x >= 42) && (x <= 49))
					{
						if (fontdata[16 * ('d') + (y0 - 8)] & (128 >> (x - 42)))
						{
							indx = 255;
						}
					}
					if ((x >= 50) && (x <= 57))
					{
						if (fontdata[16 * ('B') + (y0 - 8)] & (128 >> (x - 50)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];
					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
	}
	fclose(fd);
	if (kml)	// Write colorkey image file
	{
		err = fopen_s(&fd, ckfile, "wb");
		height = 30 * region->levels;
		width = 100;
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		for (y0 = 0; y0 < (int)height; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = y0 / 30;
				x = x0;
				level = region->level[indx];
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if (((y0 % 30) >= 8) && ((y0 % 30) <= 23))
				{
					if (hundreds > 0)
					{
						if ((x >= 11) && (x <= 18))
						{
							if (fontdata[16 * (hundreds + '0') + ((y0 % 30) - 8)] & (128 >> (x - 11)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if ((x >= 19) && (x <= 26))
						{
							if (fontdata[16 * (tens + '0') + ((y0 % 30) - 8)] & (128 >> (x - 19)))
							{
								indx = 255;
							}
						}
					}
					if ((x >= 27) && (x <= 34))
					{
						if (fontdata[16 * (units + '0') + ((y0 % 30) - 8)] & (128 >> (x - 27)))
						{
							indx = 255;
						}
					}
					if ((x >= 42) && (x <= 49))
					{
						if (fontdata[16 * ('d') + ((y0 % 30) - 8)] & (128 >> (x - 42)))
						{
							indx = 255;
						}
					}
					if ((x >= 50) && (x <= 57))
					{
						if (fontdata[16 * ('B') + ((y0 % 30) - 8)] & (128 >> (x - 50)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];

					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
		fclose(fd);
	}
	fprintf(stdout, "Done\n");
	fflush(stdout);
}


//| ------------------------------
//| 
//| FUNCTION: WritePortablePixMapSignalStrengthFile
//| 
//| OLD NAME: WritePPMSS
//| 
//| NOTES: 
//|   This function generates a topographic map in Portable Pix Map
//|   (PPM) format based on the signal strength values held in the
//|   signal[][] array. The image created is rotated counter-clockwise
//|   90 degrees from its representation in digitalElevationModel[][] so that north
//|   points up and east points right in the image generated.
//| 
//| ------------------------------
void
WritePortablePixMapSignalStrengthFile(
	char* filename,
	unsigned char geo,
	unsigned char kml,
	unsigned char ngs,
	Site* xmtr,
	unsigned char txsites,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	ColorRegion* region,
	unsigned char displaySmoothContourLevels,
	int contourDisplayThreshold,
	int maximumElevation,
	int minimumElevation,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	char mapfile[255], geofile[255], kmlfile[255], ckfile[255];
	unsigned width, height, terrain, red, green, blue;
	bool found, cityorcounty;
	unsigned char mask;
	int indx, x, y, z = 1, x0, y0, signal, level, hundreds,
		tens, units, match, colorwidth;
	double conversion, one_over_gamma, latitude, longitude,
		north, south, east, west, minwest;
	FILE* fd;
	errno_t err;

	one_over_gamma = 1.0 / GAMMA;
	conversion = 255.0 / pow(ToDouble(maximumElevation - minimumElevation), one_over_gamma);
	width = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));
	height = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLatitudeNorth - minimumLatitudeNorth)));
	LoadSplatSignalColorsForSite(xmtr[0], region);
	if (filename[0] == 0)
	{
		err = strncpy_s(filename, 255, xmtr[0].filename, 254);
		filename[strlen(filename) - 4] = 0;  // Remove .qth
	}
	y = (int)strlen(filename);
	if (y > 240)
	{
		y = 240;
	}
	if (y > 4)
	{
		if ((filename[y - 1] == 'm') && (filename[y - 2] == 'p') && (filename[y - 3] == 'p') && (filename[y - 4] == '.'))
		{
			y -= 4;
		}
	}
	for (x = 0; x < y; x++)
	{
		mapfile[x] = filename[x];
		geofile[x] = filename[x];
		kmlfile[x] = filename[x];
		ckfile[x] = filename[x];
	}
	mapfile[x] = '.';
	geofile[x] = '.';
	kmlfile[x] = '.';
	mapfile[x + 1] = 'p';
	geofile[x + 1] = 'g';
	kmlfile[x + 1] = 'k';
	mapfile[x + 2] = 'p';
	geofile[x + 2] = 'e';
	kmlfile[x + 2] = 'm';
	mapfile[x + 3] = 'm';
	geofile[x + 3] = 'o';
	kmlfile[x + 3] = 'l';
	mapfile[x + 4] = 0;
	geofile[x + 4] = 0;
	kmlfile[x + 4] = 0;
	ckfile[x] = '-';
	ckfile[x + 1] = 'c';
	ckfile[x + 2] = 'k';
	ckfile[x + 3] = '.';
	ckfile[x + 4] = 'p';
	ckfile[x + 5] = 'p';
	ckfile[x + 6] = 'm';
	ckfile[x + 7] = 0;
	minwest = ((double)minimumLongitudeWest) + (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (minwest > 360.0)
	{
		minwest -= 360.0;
	}
	north = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (kml || geo)
	{
		south = (double)minimumLatitudeNorth;	// No bottom legend
	}
	else
	{
		south = (double)minimumLatitudeNorth - (30.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));	// 30 pixels for bottom legend
	}
	east = (minwest < 180.0 ? -minwest : 360.0 - minimumLongitudeWest);
	west = (double)(maximumLongitudeWest < 180 ? -maximumLongitudeWest : 360 - maximumLongitudeWest);
	if (geo && (kml == 0))
	{
		err = fopen_s(&fd, geofile, "wb");
		fprintf(fd, "FILENAME\t%s\n", mapfile);
		fprintf(fd, "#\t\tX\tY\tLong\t\tLat\n");
		fprintf(fd, "TIEPOINT\t0\t0\t%.3f\t\t%.3f\n", west, north);
		fprintf(fd, "TIEPOINT\t%u\t%u\t%.3f\t\t%.3f\n", width - 1, height - 1, east, south);
		fprintf(fd, "IMAGESIZE\t%u\t%u\n", width, height);
		fprintf(fd, "#\n# Auto Generated by %s v%s\n#\n", APP_NAME, VERSION_HEADER);
		fclose(fd);
	}
	if (kml && (geo == 0))
	{
		err = fopen_s(&fd, kmlfile, "wb");
		fprintf(fd, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(fd, "<kml xmlns=\"http://earth.google.com/kml/2.1\">\n");
		fprintf(fd, "<!-- Generated by %s Version %s -->\n", APP_NAME, VERSION_HEADER);
		fprintf(fd, "  <Folder>\n");
		fprintf(fd, "   <name>%s</name>\n", APP_NAME);
		fprintf(fd, "     <description>%s Transmitter Contours</description>\n", xmtr[0].name);
		fprintf(fd, "       <GroundOverlay>\n");
		fprintf(fd, "         <name>SPLAT Signal Strength Contours</name>\n");
		fprintf(fd, "           <description>SPLAT Coverage</description>\n");
		fprintf(fd, "		<Icon>\n");
		fprintf(fd, "              <href>%s</href>\n", mapfile);
		fprintf(fd, "		</Icon>\n");
		//fprintf(fd,"            <opacity>128</opacity>\n");
		fprintf(fd, "            <LatLonBox>\n");
		fprintf(fd, "               <north>%.5f</north>\n", north);
		fprintf(fd, "               <south>%.5f</south>\n", south);
		fprintf(fd, "               <east>%.5f</east>\n", east);
		fprintf(fd, "               <west>%.5f</west>\n", west);
		fprintf(fd, "               <rotation>0.0</rotation>\n");
		fprintf(fd, "            </LatLonBox>\n");
		fprintf(fd, "       </GroundOverlay>\n");
		fprintf(fd, "       <ScreenOverlay>\n");
		fprintf(fd, "          <name>Color Key</name>\n");
		fprintf(fd, "            <description>Contour Color Key</description>\n");
		fprintf(fd, "          <Icon>\n");
		fprintf(fd, "            <href>%s</href>\n", ckfile);
		fprintf(fd, "          </Icon>\n");
		fprintf(fd, "          <overlayXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <screenXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <rotationXY x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <size x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "       </ScreenOverlay>\n");
		for (x = 0; x < txsites; x++)
		{
			fprintf(fd, "     <Placemark>\n");
			fprintf(fd, "       <name>%s</name>\n", xmtr[x].name);
			fprintf(fd, "       <visibility>1</visibility>\n");
			fprintf(fd, "       <Style>\n");
			fprintf(fd, "       <IconStyle>\n");
			fprintf(fd, "        <Icon>\n");
			fprintf(fd, "          <href>root://icons/palette-5.png</href>\n");
			fprintf(fd, "          <x>224</x>\n");
			fprintf(fd, "          <y>224</y>\n");
			fprintf(fd, "          <w>32</w>\n");
			fprintf(fd, "          <h>32</h>\n");
			fprintf(fd, "        </Icon>\n");
			fprintf(fd, "       </IconStyle>\n");
			fprintf(fd, "       </Style>\n");
			fprintf(fd, "      <Point>\n");
			fprintf(fd, "        <extrude>1</extrude>\n");
			fprintf(fd, "        <altitudeMode>relativeToGround</altitudeMode>\n");
			fprintf(fd, "        <coordinates>%f,%f,%f</coordinates>\n", (xmtr[x].longitude < 180.0 ? -xmtr[x].longitude : 360.0 - xmtr[x].longitude), xmtr[x].latitude, xmtr[x].altitude);
			fprintf(fd, "      </Point>\n");
			fprintf(fd, "     </Placemark>\n");
		}
		fprintf(fd, "  </Folder>\n");
		fprintf(fd, "</kml>\n");
		fclose(fd);
	}
	err = fopen_s(&fd, mapfile, "wb");
	if (kml || geo)	// No bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height);
	}
	else			// Allow space for bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height + 30);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height + 30);
	}
	fflush(stdout);
	for (y = 0, latitude = north; y < (int)height; y++, latitude = (north - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)y)))
	{
		for (x = 0, longitude = maximumLongitudeWest; x < (int)width; x++, longitude = (maximumLongitudeWest - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)x)))
		{
			if (longitude < 0.0)
			{
				longitude += 360.0;
			}
			for (indx = 0, found = false; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
			{
				x0 = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * (latitude - (double)digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
				y0 = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference((double)digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));

				if ((x0 >= 0) && (x0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y0 >= 0) && (y0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
				{
					found = true;
				}
				else
				{
					indx++;
				}
			}
			if (found)
			{
				mask = digitalElevationModelWrapper->digitalElevationModel[indx].mask[x0][y0];
				signal = digitalElevationModelWrapper->digitalElevationModel[indx].signal[x0][y0] - 100;
				cityorcounty = false;
				match = 255;
				red = 0;
				green = 0;
				blue = 0;
				if (signal >= region->level[0])
				{
					match = 0;
				}
				else
				{
					for (z = 1; (z < region->levels) && (match == 255); z++)
					{
						if ((signal < region->level[z - 1]) && (signal >= region->level[z]))
						{
							match = z;
						}
					}
				}
				if (match < region->levels)
				{
					if (displaySmoothContourLevels && (match > 0))
					{
						red = (unsigned)LinearInterpolation(region->color[match][0], region->color[match - 1][0], region->level[match], region->level[match - 1], signal);
						green = (unsigned)LinearInterpolation(region->color[match][1], region->color[match - 1][1], region->level[match], region->level[match - 1], signal);
						blue = (unsigned)LinearInterpolation(region->color[match][2], region->color[match - 1][2], region->level[match], region->level[match - 1], signal);
					}
					else
					{
						red = region->color[match][0];
						green = region->color[match][1];
						blue = region->color[match][2];
					}
				}
				if (mask & 2)	// Text Labels: Red or otherwise
				{
					if ((red >= 180) && (green <= 75) && (blue <= 75))
					{
						fprintf(fd, "%c%c%c", 255 ^ red, 255 ^ green, 255 ^ blue);
					}
					else
					{
						fprintf(fd, "%c%c%c", 255, 0, 0);
					}
					cityorcounty = true;
				}
				else if (mask & 4)	// County Boundaries: Black
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
					cityorcounty = true;
				}
				if (cityorcounty == false)
				{
					if ((contourDisplayThreshold != 0) && (signal < contourDisplayThreshold))
					{
						if (ngs)
						{
							fprintf(fd, "%c%c%c", 255, 255, 255);
						}
						else	// Display land or sea elevation
						{
							if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)
							{
								fprintf(fd, "%c%c%c", 0, 0, 170);
							}
							else
							{
								terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
								fprintf(fd, "%c%c%c", terrain, terrain, terrain);
							}
						}
					}
					else
					{
						if ((red != 0) || (green != 0) || (blue != 0))	// Plot field strength regions in color
						{
							fprintf(fd, "%c%c%c", red, green, blue);
						}
						else  // terrain / sea-level
						{
							if (ngs)
							{
								fprintf(fd, "%c%c%c", 255, 255, 255);
							}
							else
							{
								if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)
								{
									fprintf(fd, "%c%c%c", 0, 0, 170);
								}
								else	// Elevation: Greyscale
								{
									terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
									fprintf(fd, "%c%c%c", terrain, terrain, terrain);
								}
							}
						}
					}
				}
			}
			else	// We should never get here, but if we do, display the region as black
			{
				fprintf(fd, "%c%c%c", 0, 0, 0);
			}
		}
	}
	if ((kml == 0) && (geo == 0))	// Display legend along bottom of image if not generating .kml or .geo output.
	{
		colorwidth = (int)rint((float)width / (float)region->levels);
		for (y0 = 0; y0 < 30; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = x0 / colorwidth;
				x = x0 % colorwidth;
				level = region->level[indx];
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if ((y0 >= 8) && (y0 <= 23))
				{
					if (hundreds > 0)
					{
						if ((x >= 5) && (x <= 12))
						{
							if (fontdata[16 * (hundreds + '0') + (y0 - 8)] & (128 >> (x - 5)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if ((x >= 13) && (x <= 20))
						{
							if (fontdata[16 * (tens + '0') + (y0 - 8)] & (128 >> (x - 13)))
							{
								indx = 255;
							}
						}
					}
					if ((x >= 21) && (x <= 28))
					{
						if (fontdata[16 * (units + '0') + (y0 - 8)] & (128 >> (x - 21)))
						{
							indx = 255;
						}
					}
					if ((x >= 36) && (x <= 43))
					{
						if (fontdata[16 * ('d') + (y0 - 8)] & (128 >> (x - 36)))
						{
							indx = 255;
						}
					}
					if ((x >= 44) && (x <= 51))
					{
						if (fontdata[16 * ('B') + (y0 - 8)] & (128 >> (x - 44)))
						{
							indx = 255;
						}
					}
					if ((x >= 52) && (x <= 59))
					{
						if (fontdata[16 * (230) + (y0 - 8)] & (128 >> (x - 52)))
						{
							indx = 255;
						}
					}
					if ((x >= 60) && (x <= 67))
					{
						if (fontdata[16 * ('V') + (y0 - 8)] & (128 >> (x - 60)))
						{
							indx = 255;
						}
					}
					if ((x >= 68) && (x <= 75))
					{
						if (fontdata[16 * ('\\') + (y0 - 8)] & (128 >> (x - 68)))
						{
							indx = 255;
						}
					}
					if ((x >= 76) && (x <= 83))
					{
						if (fontdata[16 * ('m') + (y0 - 8)] & (128 >> (x - 76)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];
					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
	}
	fclose(fd);
	if (kml)	// Write colorkey image file
	{
		err = fopen_s(&fd, ckfile, "wb");
		height = 30 * region->levels;
		width = 100;
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		for (y0 = 0; y0 < (int)height; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = y0 / 30;
				x = x0;
				level = region->level[indx];
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if (((y0 % 30) >= 8) && ((y0 % 30) <= 23))
				{
					if (hundreds > 0)
					{
						if ((x >= 5) && (x <= 12))
						{
							if (fontdata[16 * (hundreds + '0') + ((y0 % 30) - 8)] & (128 >> (x - 5)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if ((x >= 13) && (x <= 20))
						{
							if (fontdata[16 * (tens + '0') + ((y0 % 30) - 8)] & (128 >> (x - 13)))
							{
								indx = 255;
							}
						}
					}
					if ((x >= 21) && (x <= 28))
					{
						if (fontdata[16 * (units + '0') + ((y0 % 30) - 8)] & (128 >> (x - 21)))
						{
							indx = 255;
						}
					}
					if ((x >= 36) && (x <= 43))
					{
						if (fontdata[16 * ('d') + ((y0 % 30) - 8)] & (128 >> (x - 36)))
						{
							indx = 255;
						}
					}
					if ((x >= 44) && (x <= 51))
					{
						if (fontdata[16 * ('B') + ((y0 % 30) - 8)] & (128 >> (x - 44)))
						{
							indx = 255;
						}
					}
					if ((x >= 52) && (x <= 59))
					{
						if (fontdata[16 * (230) + ((y0 % 30) - 8)] & (128 >> (x - 52)))
						{
							indx = 255;
						}
					}
					if ((x >= 60) && (x <= 67))
					{
						if (fontdata[16 * ('V') + ((y0 % 30) - 8)] & (128 >> (x - 60)))
						{
							indx = 255;
						}
					}
					if ((x >= 68) && (x <= 75))
					{
						if (fontdata[16 * ('\\') + ((y0 % 30) - 8)] & (128 >> (x - 68)))
						{
							indx = 255;
						}
					}
					if ((x >= 76) && (x <= 83))
					{
						if (fontdata[16 * ('m') + ((y0 % 30) - 8)] & (128 >> (x - 76)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];

					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
		fclose(fd);
	}
	fprintf(stdout, "Done\n");
	fflush(stdout);
}


//| ------------------------------
//| 
//| FUNCTION: WritePortablePixMapPowerLevelFile
//| 
//| OLD NAME: WritePPMDBM
//| 
//| NOTES: 
//|   This function generates a topographic map in Portable Pix Map
//|   (PPM) format based on the signal power level values held in the
//|   signal[][] array. The image created is rotated counter-clockwise
//|   90 degrees from its representation in digitalElevationModel[][] so that north
//|   points up and east points right in the image generated.
//| 
//| ------------------------------
void
WritePortablePixMapPowerLevelFile(
	char* filename,
	unsigned char geo,
	unsigned char kml,
	unsigned char ngs,
	Site* xmtr,
	unsigned char txsites,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	ColorRegion* region,
	unsigned char displaySmoothContourLevels,
	int contourDisplayThreshold,
	int maximumElevation,
	int minimumElevation,
	int minimumLatitudeNorth,
	int maximumLatitudeNorth,
	int minimumLongitudeWest,
	int maximumLongitudeWest)
{
	char mapfile[255], geofile[255], kmlfile[255], ckfile[255];
	unsigned width, height, terrain, red, green, blue;
	bool found, cityorcounty;
	unsigned char mask;
	int indx, x, y, z = 1, x0, y0, dBm, level, hundreds,
		tens, units, match, colorwidth;
	double conversion, one_over_gamma, latitude, longitude,
		north, south, east, west, minwest;
	FILE* fd;
	errno_t err;

	one_over_gamma = 1.0 / GAMMA;
	conversion = 255.0 / pow(ToDouble(maximumElevation - minimumElevation), one_over_gamma);
	width = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLongitudeWest - minimumLongitudeWest)));
	height = (unsigned)(digitalElevationModelWrapper->demPixelsPerDegree * ConvertToNormalizedAngle(ToDouble(maximumLatitudeNorth - minimumLatitudeNorth)));
	LoadSplatPowerColorsForSite(xmtr[0], region);
	if (filename[0] == 0)
	{
		err = strncpy_s(filename, 255, xmtr[0].filename, 254);
		filename[strlen(filename) - 4] = 0;  // Remove .qth
	}
	y = (int)strlen(filename);
	if (y > 240)
	{
		y = 240;
	}
	if (y > 4)
	{
		if ((filename[y - 1] == 'm') && (filename[y - 2] == 'p') && (filename[y - 3] == 'p') && (filename[y - 4] == '.'))
		{
			y -= 4;
		}
	}
	for (x = 0; x < y; x++)
	{
		mapfile[x] = filename[x];
		geofile[x] = filename[x];
		kmlfile[x] = filename[x];
		ckfile[x] = filename[x];
	}
	mapfile[x] = '.';
	geofile[x] = '.';
	kmlfile[x] = '.';
	mapfile[x + 1] = 'p';
	geofile[x + 1] = 'g';
	kmlfile[x + 1] = 'k';
	mapfile[x + 2] = 'p';
	geofile[x + 2] = 'e';
	kmlfile[x + 2] = 'm';
	mapfile[x + 3] = 'm';
	geofile[x + 3] = 'o';
	kmlfile[x + 3] = 'l';
	mapfile[x + 4] = 0;
	geofile[x + 4] = 0;
	kmlfile[x + 4] = 0;
	ckfile[x] = '-';
	ckfile[x + 1] = 'c';
	ckfile[x + 2] = 'k';
	ckfile[x + 3] = '.';
	ckfile[x + 4] = 'p';
	ckfile[x + 5] = 'p';
	ckfile[x + 6] = 'm';
	ckfile[x + 7] = 0;
	minwest = ((double)minimumLongitudeWest) + (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (minwest > 360.0)
	{
		minwest -= 360.0;
	}
	north = (double)maximumLatitudeNorth - (1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));
	if (kml || geo)
	{
		south = (double)minimumLatitudeNorth;	// No bottom legend
	}
	else
	{
		south = (double)minimumLatitudeNorth - (30.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree));	// 30 pixels for bottom legend
	}
	east = (minwest < 180.0 ? -minwest : 360.0 - minimumLongitudeWest);
	west = (double)(maximumLongitudeWest < 180 ? -maximumLongitudeWest : 360 - maximumLongitudeWest);
	if (geo && (kml == 0))
	{
		err = fopen_s(&fd, geofile, "wb");
		fprintf(fd, "FILENAME\t%s\n", mapfile);
		fprintf(fd, "#\t\tX\tY\tLong\t\tLat\n");
		fprintf(fd, "TIEPOINT\t0\t0\t%.3f\t\t%.3f\n", west, north);
		fprintf(fd, "TIEPOINT\t%u\t%u\t%.3f\t\t%.3f\n", width - 1, height - 1, east, south);
		fprintf(fd, "IMAGESIZE\t%u\t%u\n", width, height);
		fprintf(fd, "#\n# Auto Generated by %s v%s\n#\n", APP_NAME, VERSION_HEADER);
		fclose(fd);
	}
	if (kml && (geo == 0))
	{
		err = fopen_s(&fd, kmlfile, "wb");
		fprintf(fd, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		fprintf(fd, "<kml xmlns=\"http://earth.google.com/kml/2.1\">\n");
		fprintf(fd, "<!-- Generated by %s Version %s -->\n", APP_NAME, VERSION_HEADER);
		fprintf(fd, "  <Folder>\n");
		fprintf(fd, "   <name>%s</name>\n", APP_NAME);
		fprintf(fd, "     <description>%s Transmitter Contours</description>\n", xmtr[0].name);
		fprintf(fd, "       <GroundOverlay>\n");
		fprintf(fd, "         <name>SPLAT Signal Power Level Contours</name>\n");
		fprintf(fd, "           <description>SPLAT Coverage</description>\n");
		fprintf(fd, "		<Icon>\n");
		fprintf(fd, "              <href>%s</href>\n", mapfile);
		fprintf(fd, "		</Icon>\n");
		//fprintf(fd,"            <opacity>128</opacity>\n");
		fprintf(fd, "            <LatLonBox>\n");
		fprintf(fd, "               <north>%.5f</north>\n", north);
		fprintf(fd, "               <south>%.5f</south>\n", south);
		fprintf(fd, "               <east>%.5f</east>\n", east);
		fprintf(fd, "               <west>%.5f</west>\n", west);
		fprintf(fd, "               <rotation>0.0</rotation>\n");
		fprintf(fd, "            </LatLonBox>\n");
		fprintf(fd, "       </GroundOverlay>\n");
		fprintf(fd, "       <ScreenOverlay>\n");
		fprintf(fd, "          <name>Color Key</name>\n");
		fprintf(fd, "            <description>Contour Color Key</description>\n");
		fprintf(fd, "          <Icon>\n");
		fprintf(fd, "            <href>%s</href>\n", ckfile);
		fprintf(fd, "          </Icon>\n");
		fprintf(fd, "          <overlayXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <screenXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <rotationXY x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "          <size x=\"0\" y=\"0\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
		fprintf(fd, "       </ScreenOverlay>\n");
		for (x = 0; x < txsites; x++)
		{
			fprintf(fd, "     <Placemark>\n");
			fprintf(fd, "       <name>%s</name>\n", xmtr[x].name);
			fprintf(fd, "       <visibility>1</visibility>\n");
			fprintf(fd, "       <Style>\n");
			fprintf(fd, "       <IconStyle>\n");
			fprintf(fd, "        <Icon>\n");
			fprintf(fd, "          <href>root://icons/palette-5.png</href>\n");
			fprintf(fd, "          <x>224</x>\n");
			fprintf(fd, "          <y>224</y>\n");
			fprintf(fd, "          <w>32</w>\n");
			fprintf(fd, "          <h>32</h>\n");
			fprintf(fd, "        </Icon>\n");
			fprintf(fd, "       </IconStyle>\n");
			fprintf(fd, "       </Style>\n");
			fprintf(fd, "      <Point>\n");
			fprintf(fd, "        <extrude>1</extrude>\n");
			fprintf(fd, "        <altitudeMode>relativeToGround</altitudeMode>\n");
			fprintf(fd, "        <coordinates>%f,%f,%f</coordinates>\n", (xmtr[x].longitude < 180.0 ? -xmtr[x].longitude : 360.0 - xmtr[x].longitude), xmtr[x].latitude, xmtr[x].altitude);
			fprintf(fd, "      </Point>\n");
			fprintf(fd, "     </Placemark>\n");
		}
		fprintf(fd, "  </Folder>\n");
		fprintf(fd, "</kml>\n");
		fclose(fd);
	}
	err = fopen_s(&fd, mapfile, "wb");
	if (kml || geo)	// No bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height);
	}
	else			// Allow for bottom legend
	{
		fprintf(fd, "P6\n%u %u\n255\n", width, height + 30);
		fprintf(stdout, "\nWriting \"%s\" (%ux%u pixmap image)... ", mapfile, width, height + 30);
	}
	fflush(stdout);
	for (y = 0, latitude = north; y < (int)height; y++, latitude = (north - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)y)))
	{
		for (x = 0, longitude = maximumLongitudeWest; x < (int)width; x++, longitude = (maximumLongitudeWest - ((1.0 / ((double)digitalElevationModelWrapper->demPixelsPerDegree)) * (double)x)))
		{
			if (longitude < 0.0)
			{
				longitude += 360.0;
			}
			for (indx = 0, found = false; (indx < digitalElevationModelWrapper->maxPages) && (found == false);)
			{
				x0 = (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * (latitude - (double)digitalElevationModelWrapper->digitalElevationModel[indx].minimumLatitudeNorth));
				y0 = (digitalElevationModelWrapper->demPixelsPerDegree - 1) - (int)rint(((double)digitalElevationModelWrapper->demPixelsPerDegree) * LongitudeDifference((double)digitalElevationModelWrapper->digitalElevationModel[indx].maximumLongitudeWest, longitude));
				if ((x0 >= 0) && (x0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)) && (y0 >= 0) && (y0 <= (digitalElevationModelWrapper->demPixelsPerDegree - 1)))
				{
					found = true;
				}
				else
				{
					indx++;
				}
			}
			if (found)
			{
				mask = digitalElevationModelWrapper->digitalElevationModel[indx].mask[x0][y0];
				dBm = digitalElevationModelWrapper->digitalElevationModel[indx].signal[x0][y0] - 200;
				cityorcounty = false;
				match = 255;
				red = 0;
				green = 0;
				blue = 0;
				if (dBm >= region->level[0])
				{
					match = 0;
				}
				else
				{
					for (z = 1; (z < region->levels) && (match == 255); z++)
					{
						if ((dBm < region->level[z - 1]) && (dBm >= region->level[z]))
						{
							match = z;
						}
					}
				}
				if (match < region->levels)
				{
					if (displaySmoothContourLevels && (match > 0))
					{
						red = (unsigned)LinearInterpolation(region->color[match][0], region->color[match - 1][0], region->level[match], region->level[match - 1], dBm);
						green = (unsigned)LinearInterpolation(region->color[match][1], region->color[match - 1][1], region->level[match], region->level[match - 1], dBm);
						blue = (unsigned)LinearInterpolation(region->color[match][2], region->color[match - 1][2], region->level[match], region->level[match - 1], dBm);
					}
					else
					{
						red = region->color[match][0];
						green = region->color[match][1];
						blue = region->color[match][2];
					}
				}
				if (mask & 2)	// Text Labels: Red or otherwise
				{
					if ((red >= 180) && (green <= 75) && (blue <= 75) && (dBm != 0))
					{
						fprintf(fd, "%c%c%c", 255 ^ red, 255 ^ green, 255 ^ blue);
					}
					else
					{
						fprintf(fd, "%c%c%c", 255, 0, 0);
					}
					cityorcounty = true;
				}
				else if (mask & 4)	// County Boundaries: Black
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
					cityorcounty = true;
				}
				if (cityorcounty == false)
				{
					if ((contourDisplayThreshold != 0) && (dBm < contourDisplayThreshold))
					{
						if (ngs) // No terrain
						{
							fprintf(fd, "%c%c%c", 255, 255, 255);
						}
						else	// Display land or sea elevation
						{
							if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)
							{
								fprintf(fd, "%c%c%c", 0, 0, 170);
							}
							else
							{
								terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
								fprintf(fd, "%c%c%c", terrain, terrain, terrain);
							}
						}
					}
					else
					{
						if ((red != 0) || (green != 0) || (blue != 0))	// Plot signal power level regions in color
						{
							fprintf(fd, "%c%c%c", red, green, blue);
						}
						else  // terrain / sea-level
						{
							if (ngs)
							{
								fprintf(fd, "%c%c%c", 255, 255, 255);
							}
							else
							{
								if (digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] == 0)
								{
									fprintf(fd, "%c%c%c", 0, 0, 170);
								}
								else	// Elevation: Greyscale
								{
									terrain = (unsigned)(0.5 + pow(ToDouble(digitalElevationModelWrapper->digitalElevationModel[indx].data[x0][y0] - minimumElevation), one_over_gamma) * conversion);
									fprintf(fd, "%c%c%c", terrain, terrain, terrain);
								}
							}
						}
					}
				}
			}
			else	// We should never get here, but if we do, display the region as black
			{
				fprintf(fd, "%c%c%c", 0, 0, 0);
			}
		}
	}
	if ((kml == 0) && (geo == 0))	// Display legend along bottom of image if not generating .kml or .geo output.
	{
		colorwidth = (int)rint((float)width / (float)region->levels);
		for (y0 = 0; y0 < 30; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = x0 / colorwidth;
				x = x0 % colorwidth;
				level = abs(region->level[indx]);
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if ((y0 >= 8) && (y0 <= 23))
				{
					if (hundreds > 0)
					{
						if (region->level[indx] < 0)
						{
							if ((x >= 5) && (x <= 12))
							{
								if (fontdata[16 * ('-') + (y0 - 8)] & (128 >> (x - 5)))
								{
									indx = 255;
								}
							}
						}
						else
						{
							if ((x >= 5) && (x <= 12))
							{
								if (fontdata[16 * ('+') + (y0 - 8)] & (128 >> (x - 5)))
								{
									indx = 255;
								}
							}
						}
						if ((x >= 13) && (x <= 20))
						{
							if (fontdata[16 * (hundreds + '0') + (y0 - 8)] & (128 >> (x - 13)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if (hundreds == 0)
						{
							if (region->level[indx] < 0)
							{
								if ((x >= 13) && (x <= 20))
								{
									if (fontdata[16 * ('-') + (y0 - 8)] & (128 >> (x - 13)))
									{
										indx = 255;
									}
								}
							}
							else
							{
								if ((x >= 13) && (x <= 20))
								{
									if (fontdata[16 * ('+') + (y0 - 8)] & (128 >> (x - 13)))
									{
										indx = 255;
									}
								}
							}
						}
						if ((x >= 21) && (x <= 28))
						{
							if (fontdata[16 * (tens + '0') + (y0 - 8)] & (128 >> (x - 21)))
							{
								indx = 255;
							}
						}
					}
					if ((hundreds == 0) && (tens == 0))
					{
						if (region->level[indx] < 0)
						{
							if ((x >= 21) && (x <= 28))
							{
								if (fontdata[16 * ('-') + (y0 - 8)] & (128 >> (x - 21)))
								{
									indx = 255;
								}
							}
						}
						else
						{
							if ((x >= 21) && (x <= 28))
							{
								if (fontdata[16 * ('+') + (y0 - 8)] & (128 >> (x - 21)))
								{
									indx = 255;
								}
							}
						}
					}
					if ((x >= 29) && (x <= 36))
					{
						if (fontdata[16 * (units + '0') + (y0 - 8)] & (128 >> (x - 29)))
						{
							indx = 255;
						}
					}
					if ((x >= 37) && (x <= 44))
					{
						if (fontdata[16 * ('d') + (y0 - 8)] & (128 >> (x - 37)))
						{
							indx = 255;
						}
					}
					if ((x >= 45) && (x <= 52))
					{
						if (fontdata[16 * ('B') + (y0 - 8)] & (128 >> (x - 45)))
						{
							indx = 255;
						}
					}
					if ((x >= 53) && (x <= 60))
					{
						if (fontdata[16 * ('m') + (y0 - 8)] & (128 >> (x - 53)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];
					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
	}
	fclose(fd);
	if (kml)	// Write colorkey image file
	{
		err = fopen_s(&fd, ckfile, "wb");
		height = 30 * region->levels;
		width = 100;
		fprintf(fd, "P6\n%u %u\n255\n", width, height);
		for (y0 = 0; y0 < (int)height; y0++)
		{
			for (x0 = 0; x0 < (int)width; x0++)
			{
				indx = y0 / 30;
				x = x0;
				level = abs(region->level[indx]);
				hundreds = level / 100;
				if (hundreds > 0)
				{
					level -= (hundreds * 100);
				}
				tens = level / 10;
				if (tens > 0)
				{
					level -= (tens * 10);
				}
				units = level;
				if (((y0 % 30) >= 8) && ((y0 % 30) <= 23))
				{
					if (hundreds > 0)
					{
						if (region->level[indx] < 0)
						{
							if ((x >= 5) && (x <= 12))
							{
								if (fontdata[16 * ('-') + ((y0 % 30) - 8)] & (128 >> (x - 5)))
								{
									indx = 255;
								}
							}
						}
						else
						{
							if ((x >= 5) && (x <= 12))
							{
								if (fontdata[16 * ('+') + ((y0 % 30) - 8)] & (128 >> (x - 5)))
								{
									indx = 255;
								}
							}
						}
						if ((x >= 13) && (x <= 20))
						{
							if (fontdata[16 * (hundreds + '0') + ((y0 % 30) - 8)] & (128 >> (x - 13)))
							{
								indx = 255;
							}
						}
					}
					if ((tens > 0) || (hundreds > 0))
					{
						if (hundreds == 0)
						{
							if (region->level[indx] < 0)
							{
								if ((x >= 13) && (x <= 20))
								{
									if (fontdata[16 * ('-') + ((y0 % 30) - 8)] & (128 >> (x - 13)))
									{
										indx = 255;
									}
								}
							}
							else
							{
								if ((x >= 13) && (x <= 20))
								{
									if (fontdata[16 * ('+') + ((y0 % 30) - 8)] & (128 >> (x - 13)))
									{
										indx = 255;
									}
								}
							}
						}
						if ((x >= 21) && (x <= 28))
						{
							if (fontdata[16 * (tens + '0') + ((y0 % 30) - 8)] & (128 >> (x - 21)))
							{
								indx = 255;
							}
						}
					}
					if ((hundreds == 0) && (tens == 0))
					{
						if (region->level[indx] < 0)
						{
							if ((x >= 21) && (x <= 28))
							{
								if (fontdata[16 * ('-') + ((y0 % 30) - 8)] & (128 >> (x - 21)))
								{
									indx = 255;
								}
							}
						}
						else
						{
							if ((x >= 21) && (x <= 28))
							{
								if (fontdata[16 * ('+') + ((y0 % 30) - 8)] & (128 >> (x - 21)))
								{
									indx = 255;
								}
							}
						}
					}
					if ((x >= 29) && (x <= 36))
					{
						if (fontdata[16 * (units + '0') + ((y0 % 30) - 8)] & (128 >> (x - 29)))
						{
							indx = 255;
						}
					}
					if ((x >= 37) && (x <= 44))
					{
						if (fontdata[16 * ('d') + ((y0 % 30) - 8)] & (128 >> (x - 37)))
						{
							indx = 255;
						}
					}
					if ((x >= 45) && (x <= 52))
					{
						if (fontdata[16 * ('B') + ((y0 % 30) - 8)] & (128 >> (x - 45)))
						{
							indx = 255;
						}
					}
					if ((x >= 53) && (x <= 60))
					{
						if (fontdata[16 * ('m') + ((y0 % 30) - 8)] & (128 >> (x - 53)))
						{
							indx = 255;
						}
					}
				}
				if (indx > region->levels)
				{
					fprintf(fd, "%c%c%c", 0, 0, 0);
				}
				else
				{
					red = region->color[indx][0];
					green = region->color[indx][1];
					blue = region->color[indx][2];
					fprintf(fd, "%c%c%c", red, green, blue);
				}
			}
		}
		fclose(fd);
	}
	fprintf(stdout, "Done\n");
	fflush(stdout);
}
