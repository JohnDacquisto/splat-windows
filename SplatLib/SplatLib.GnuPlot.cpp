/****************************************************************************\
*					SplatLib.GnuPlot: GnuPlot								 *
*****************************************************************************/

#include "stdafx.h"
#include <math.h>
#include <io.h>
#include <stdlib.h>
#include <ctype.h>
#include <Windows.h>
#include "SplatLib.h"
#include "itwom.h"
#include "fontdata.h"
#include "..\Common\Common.h"
#include "..\Common\Site.h"
#include "..\Common\version.h"
#include "..\Common\constants.h"


//| ------------------------------
//| 
//| FUNCTION: GenerateGnuPlotTerrainProfileBetweenSites
//| 
//| OLD NAME: GraphTerrain
//| 
//| NOTES: 
//|   This function invokes gnuplot to generate an appropriate
//|   output file indicating the terrain profile between the source
//|   and destination locations when the -p command line option
//|   is used. "basename" is the name assigned to the output
//|   file generated by gnuplot. The filename extension is used
//|   to set gnuplot's terminal setting and output file type.
//|   If no extension is found, .png is assumed.
//| 
//| ------------------------------
void
GenerateGnuPlotTerrainProfileBetweenSites(
	Site source,
	Site destination,
	char* name,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	char saveGnuPlotWorkingFiles,
	unsigned char useMetricUnits,
	double groundClutterHeight,
	char* reportSavePath)
{
	int	x, y, z;
	char basename[255], term[30], ext[15];
	double minheight = 100000.0, maxheight = -100000.0;
	FILE* fd = NULL, * fd1 = NULL;
	errno_t err;

	GeneratePathBetweenSites(destination, source, digitalElevationModelWrapper, path);

	char plotNameAndPath[335];
	sprintf_s(plotNameAndPath, _countof(plotNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "splat.gp");

	char profileNameAndPath[335];
	sprintf_s(profileNameAndPath, _countof(profileNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "profile.gp");

	char clutterNameAndPath[335];
	sprintf_s(clutterNameAndPath, _countof(clutterNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "clutter.gp");

	err = fopen_s(&fd, profileNameAndPath, "wb");

	if (groundClutterHeight > 0.0)
	{
		err = fopen_s(&fd1, clutterNameAndPath, "wb");
	}

	for (x = 0; x < path->pathLength; x++)
	{
		if ((path->elevations[x] + groundClutterHeight) > maxheight)
		{
			maxheight = path->elevations[x] + groundClutterHeight;
		}

		if (path->elevations[x] < minheight)
		{
			minheight = path->elevations[x];
		}

		if (useMetricUnits)
		{
			fprintf(fd, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * path->elevations[x]);

			if ((fd1 != NULL) && (x > 0) && (x < (path->pathLength - 2)))
			{
				fprintf(fd1, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * (path->elevations[x] == 0.0 ? path->elevations[x] : (path->elevations[x] + groundClutterHeight)));
			}
		}
		else
		{
			fprintf(fd, "%f\t%f\n", path->distances[x], path->elevations[x]);

			if ((fd1 != NULL) && (x > 0) && (x < (path->pathLength - 2)))
			{
				fprintf(fd1, "%f\t%f\n", path->distances[x], (path->elevations[x] == 0.0 ? path->elevations[x] : (path->elevations[x] + groundClutterHeight)));
			}
		}
	}

	fclose(fd);

	if (fd1 != NULL)
	{
		fclose(fd1);
	}

	if (name[0] == '.')
	{
		// Default filename and output file type

		err = strncpy_s(basename, _countof(basename), "profile\0", 8);
		err = strncpy_s(term, _countof(term), "png\0", 4);
		err = strncpy_s(ext, _countof(ext), "png\0", 4);
	}
	else
	{
		// Extract extension and terminal type from "name"

		ext[0] = 0;
		y = (int)strlen(name);
		err = strncpy_s(basename, _countof(basename), name, 254);

		for (x = y - 1; (x > 0) && (name[x] != '.'); x--);

		if (x > 0)  // Extension found
		{
			for (z = x + 1; (z <= y) && ((z - (x + 1)) < 10); z++)
			{
				ext[z - (x + 1)] = tolower(name[z]);
				term[z - (x + 1)] = name[z];
			}

			ext[z - (x + 1)] = 0;  // Ensure an ending 0
			term[z - (x + 1)] = 0;
			basename[x] = 0;
		}

		if (ext[0] == 0)	// No extension -- Default is png
		{
			err = strncpy_s(term, _countof(term), "png\0", 4);
			err = strncpy_s(ext, _countof(ext), "png\0", 4);
		}
	}

	// Either .ps or .postscript may be used
	// as an extension for postscript output.

	if (strncmp(term, "postscript", 10) == 0)
	{
		err = strncpy_s(ext, _countof(ext), "ps\0", 3);
	}
	else if (strncmp(ext, "ps", 2) == 0)
	{
		err = strncpy_s(term, _countof(term), "postscript enhanced color\0", 26);
	}

	if (maxheight < 1.0)
	{
		maxheight = 1.0;	// Avoid a gnuplot y-range error
		minheight = -1.0;	// over a completely sea-level path
	}
	else
	{
		minheight -= (0.01 * maxheight);
	}

	err = fopen_s(&fd, plotNameAndPath, "w");

	if (!err && fd != NULL)
	{
		fprintf(fd, "set grid\n");
		fprintf(fd, "set yrange [%2.3f to %2.3f]\n", (useMetricUnits ? minheight * METERS_PER_FOOT : minheight), (useMetricUnits ? maxheight * METERS_PER_FOOT : maxheight));
		fprintf(fd, "set encoding iso_8859_1\n");
		fprintf(fd, "set term %s\n", term);
		fprintf(fd, "set title \"%s Terrain Profile Between %s and %s (%.2f%c Azimuth)\"\n", APP_NAME, destination.name, source.name, AzimuthAngleBetweenSites(destination, source), 176);

		if (useMetricUnits)
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f kilometers)\"\n", destination.name, source.name, KM_PER_MILE * GreatCircleDistanceBetweenSiteLocations(source, destination));
			fprintf(fd, "set ylabel \"Ground Elevation Above Sea Level (meters)\"\n");
		}
		else
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f miles)\"\n", destination.name, source.name, GreatCircleDistanceBetweenSiteLocations(source, destination));
			fprintf(fd, "set ylabel \"Ground Elevation Above Sea Level (feet)\"\n");
		}

		fprintf(fd, "set output \"%s.%s\"\n", basename, ext);

		if (groundClutterHeight > 0.0)
		{
			if (useMetricUnits)
			{
				fprintf(fd, "plot \"%s\" title \"Terrain Profile\" with lines, \"%s\" title \"Clutter Profile (%.2f meters)\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight * METERS_PER_FOOT);
			}
			else
			{
				fprintf(fd, "plot \"%s\" title \"Terrain Profile\" with lines, \"%s\" title \"Clutter Profile (%.2f feet)\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight);
			}
		}
		else
		{
			fprintf(fd, "plot \"%s\" title \"\" with lines\n", profileNameAndPath);
		}

		fclose(fd);
	}

	char gnuPlotAndSplat[335];
	sprintf_s(gnuPlotAndSplat, _countof(gnuPlotAndSplat), "gnuplot \"%s\"", plotNameAndPath);

	// Invokve gnuplot and run the splat.gp script.

	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	// Start the child process.

	bool gnuplotSuccess = CreateProcess(NULL, gnuPlotAndSplat, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

	if (gnuplotSuccess == true)
	{
		// Wait until child process exits.
		WaitForSingleObject(pi.hProcess, INFINITE);

		// Close process and thread handles.
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		if (saveGnuPlotWorkingFiles == 0)
		{
			_unlink(plotNameAndPath);
			_unlink(profileNameAndPath);
		}

		fprintf(stdout, "Terrain plot written to: \"%s.%s\"\n", basename, ext);
		fflush(stdout);
	}
	else
	{
		fprintf(stderr, "\n*** ERROR: Error occurred invoking gnuplot\n");
	}
}


//| ------------------------------
//| 
//| FUNCTION: GenerateGnuPlotElevationProfileBetweenSites
//| 
//| OLD NAME: GraphElevation
//| 
//| NOTES: 
//|   This function invokes gnuplot to generate an appropriate
//|   output file indicating the elevation profile between
//|   the source and destination locations when the -e command line
//|   option is used. "basename" is the name assigned to the output
//|   file generated by gnuplot. The filename extension is used
//|   to set gnuplot's terminal setting and output file type.
//|   If no extension is found, .png is assumed.
//| 
//| ------------------------------
void
GenerateGnuPlotElevationProfileBetweenSites(
	Site source,
	Site destination,
	char* name,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	char saveGnuPlotWorkingFiles,
	unsigned char useMetricUnits,
	double groundClutterHeight,
	double sphereRadius,
	char* reportSavePath)
{
	int	x, y, z;
	char basename[255], term[30], ext[15];
	double angle, clutter_angle = 0.0, refangle, maxangle = -90.0,
		minangle = 90.0, distance;
	Site remote, remote2;
	FILE* fd = NULL, * fd1 = NULL, * fd2 = NULL;
	errno_t err;

	GeneratePathBetweenSites(destination, source, digitalElevationModelWrapper, path);  // destination=RX, source=TX
	refangle = ElevationAngleBetweenSites(destination, source, digitalElevationModelWrapper, sphereRadius);
	distance = GreatCircleDistanceBetweenSiteLocations(source, destination);

	char plotNameAndPath[335];
	sprintf_s(plotNameAndPath, _countof(plotNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "splat.gp");

	char profileNameAndPath[335];
	sprintf_s(profileNameAndPath, _countof(profileNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "profile.gp");

	char clutterNameAndPath[335];
	sprintf_s(clutterNameAndPath, _countof(clutterNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "clutter.gp");

	char referenceNameAndPath[335];
	sprintf_s(referenceNameAndPath, _countof(referenceNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "reference.gp");

	err = fopen_s(&fd, profileNameAndPath, "wb");

	if (groundClutterHeight > 0.0)
	{
		err = fopen_s(&fd1, clutterNameAndPath, "wb");
	}

	err = fopen_s(&fd2, referenceNameAndPath, "wb");

	for (x = 1; x < path->pathLength - 1; x++)
	{
		remote.latitude = path->latitudes[x];
		remote.longitude = path->longitudes[x];
		remote.altitude = 0.0;
		angle = ElevationAngleBetweenSites(destination, remote, digitalElevationModelWrapper, sphereRadius);

		if (groundClutterHeight > 0.0)
		{
			remote2.latitude = path->latitudes[x];
			remote2.longitude = path->longitudes[x];

			if (path->elevations[x] != 0.0)
			{
				remote2.altitude = (float)groundClutterHeight;
			}
			else
			{
				remote2.altitude = 0.0;
			}

			clutter_angle = ElevationAngleBetweenSites(destination, remote2, digitalElevationModelWrapper, sphereRadius);
		}

		if (useMetricUnits)
		{
			fprintf(fd, "%f\t%f\n", KM_PER_MILE * path->distances[x], angle);

			if (fd1 != NULL)
			{
				fprintf(fd1, "%f\t%f\n", KM_PER_MILE * path->distances[x], clutter_angle);
			}

			fprintf(fd2, "%f\t%f\n", KM_PER_MILE * path->distances[x], refangle);
		}
		else
		{
			fprintf(fd, "%f\t%f\n", path->distances[x], angle);

			if (fd1 != NULL)
			{
				fprintf(fd1, "%f\t%f\n", path->distances[x], clutter_angle);
			}

			fprintf(fd2, "%f\t%f\n", path->distances[x], refangle);
		}

		if (angle > maxangle)
		{
			maxangle = angle;
		}

		if (clutter_angle > maxangle)
		{
			maxangle = clutter_angle;
		}

		if (angle < minangle)
		{
			minangle = angle;
		}
	}

	if (useMetricUnits)
	{
		fprintf(fd, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], refangle);
		fprintf(fd2, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], refangle);
	}
	else
	{
		fprintf(fd, "%f\t%f\n", path->distances[path->pathLength - 1], refangle);
		fprintf(fd2, "%f\t%f\n", path->distances[path->pathLength - 1], refangle);
	}

	fclose(fd);

	if (fd1 != NULL)
	{
		fclose(fd1);
	}

	fclose(fd2);

	if (name[0] == '.')
	{
		// Default filename and output file type

		err = strncpy_s(basename, _countof(basename), "profile\0", 8);
		err = strncpy_s(term, _countof(term), "png\0", 4);
		err = strncpy_s(ext, _countof(ext), "png\0", 4);
	}
	else
	{
		// Extract extension and terminal type from "name"

		ext[0] = 0;
		y = (int)strlen(name);
		err = strncpy_s(basename, _countof(basename), name, 254);

		for (x = y - 1; (x > 0) && (name[x] != '.'); x--);

		if (x > 0)  // Extension found
		{
			for (z = x + 1; (z <= y) && ((z - (x + 1)) < 10); z++)
			{
				ext[z - (x + 1)] = tolower(name[z]);
				term[z - (x + 1)] = name[z];
			}

			ext[z - (x + 1)] = 0;  // Ensure an ending 0
			term[z - (x + 1)] = 0;
			basename[x] = 0;
		}

		if (ext[0] == 0)	// No extension -- Default is png
		{
			err = strncpy_s(term, _countof(term), "png\0", 4);
			err = strncpy_s(ext, _countof(ext), "png\0", 4);
		}
	}

	// Either .ps or .postscript may be used
	// as an extension for postscript output.

	if (strncmp(term, "postscript", 10) == 0)
	{
		err = strncpy_s(ext, _countof(ext), "ps\0", 3);
	}
	else if (strncmp(ext, "ps", 2) == 0)
	{
		err = strncpy_s(term, _countof(term), "postscript enhanced color\0", 26);
	}

	err = fopen_s(&fd, plotNameAndPath, "w");

	if (!err && fd != NULL)
	{
		fprintf(fd, "set grid\n");

		if (distance > 2.0)
		{
			fprintf(fd, "set yrange [%2.3f to %2.3f]\n", (-fabs(refangle) - 0.25), maxangle + 0.25);
		}
		else
		{
			fprintf(fd, "set yrange [%2.3f to %2.3f]\n", minangle, refangle + (-minangle / 8.0));
		}

		fprintf(fd, "set encoding iso_8859_1\n");
		fprintf(fd, "set term %s\n", term);
		fprintf(fd, "set title \"%s Elevation Profile Between %s and %s (%.2f%c azimuth)\"\n", APP_NAME, destination.name, source.name, AzimuthAngleBetweenSites(destination, source), 176);

		if (useMetricUnits)
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f kilometers)\"\n", destination.name, source.name, KM_PER_MILE * distance);
		}
		else
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f miles)\"\n", destination.name, source.name, distance);
		}

		fprintf(fd, "set ylabel \"Elevation Angle Along LOS Path Between\\n%s and %s (degrees)\"\n", destination.name, source.name);
		fprintf(fd, "set output \"%s.%s\"\n", basename, ext);

		if (groundClutterHeight > 0.0)
		{
			if (useMetricUnits)
			{
				fprintf(fd, "plot \"%s\" title \"Real Earth Profile\" with lines, \"%s\" title \"Clutter Profile (%.2f meters)\" with lines, \"%s\" title \"Line of Sight Path (%.2f%c elevation)\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight * METERS_PER_FOOT, referenceNameAndPath, refangle, 176);
			}
			else
			{
				fprintf(fd, "plot \"%s\" title \"Real Earth Profile\" with lines, \"%s\" title \"Clutter Profile (%.2f feet)\" with lines, \"%s\" title \"Line of Sight Path (%.2f%c elevation)\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight, referenceNameAndPath, refangle, 176);
			}
		}
		else
		{
			fprintf(fd, "plot \"%s\" title \"Real Earth Profile\" with lines, \"%s\" title \"Line of Sight Path (%.2f%c elevation)\" with lines\n", profileNameAndPath, referenceNameAndPath, refangle, 176);
		}

		fclose(fd);
	}

	char gnuPlotAndSplat[335];
	sprintf_s(gnuPlotAndSplat, _countof(gnuPlotAndSplat), "gnuplot \"%s\"", plotNameAndPath);

	// Invokve gnuplot and run the splat.gp script.

	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	// Start the child process.

	bool gnuplotSuccess = CreateProcess(NULL, gnuPlotAndSplat, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

	if (gnuplotSuccess == true)
	{
		// Wait until child process exits.
		WaitForSingleObject(pi.hProcess, INFINITE);

		// Close process and thread handles.
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		if (saveGnuPlotWorkingFiles == 0)
		{
			_unlink(plotNameAndPath);
			_unlink(profileNameAndPath);
			_unlink(referenceNameAndPath);

			if (groundClutterHeight > 0.0)
			{
				_unlink(clutterNameAndPath);
			}
		}

		fprintf(stdout, "Elevation plot written to: \"%s.%s\"\n", basename, ext);
		fflush(stdout);
	}
	else
	{
		fprintf(stderr, "\n*** ERROR: Error occurred invoking gnuplot\n");
	}
}


//| ------------------------------
//| 
//| FUNCTION: GenerateGnuPlotHeightProfileBetweenSites
//| 
//| OLD NAME: GraphHeight
//| 
//| NOTES: 
//|   This function invokes gnuplot to generate an appropriate
//|   output file indicating the terrain height profile between
//|   the source and destination locations referenced to the
//|   line-of-sight path between the receive and transmit sites
//|   when the -h or -H command line option is used. "basename"
//|   is the name assigned to the output file generated by gnuplot.
//|   The filename extension is used to set gnuplot's terminal
//|   setting and output file type. If no extension is found,
//|   .png is assumed.
//| 
//| ------------------------------
void
GenerateGnuPlotHeightProfileBetweenSites(
	Site source,
	Site destination,
	char* name,
	unsigned char fresnel_plot,
	unsigned char normalized,
	DigitalElevationModelWrapper* digitalElevationModelWrapper,
	Path* path,
	IrregularTerrainModelParameters* itmParameters,
	char saveGnuPlotWorkingFiles,
	unsigned char useMetricUnits,
	double groundClutterHeight,
	double fresnelZoneClearanceRatio,
	double sphereRadius,
	char* reportSavePath)
{
	int	x, y, z;
	char basename[255], term[30], ext[15];
	double a, b, c, height = 0.0, refangle, cangle, maxheight = -100000.0,
		minheight = 100000.0, lambda = 0.0, f_zone = 0.0, fpt6_zone = 0.0,
		nm = 0.0, nb = 0.0, ed = 0.0, es = 0.0, r = 0.0, d = 0.0, d1 = 0.0,
		terrain, azimuth, distance, dheight = 0.0, minterrain = 100000.0,
		minearth = 100000.0, miny, maxy, min2y, max2y;
	Site remote;
	FILE* fd = NULL, * fd1 = NULL, * fd2 = NULL, * fd3 = NULL, * fd4 = NULL, * fd5 = NULL;
	errno_t err;

	GeneratePathBetweenSites(destination, source, digitalElevationModelWrapper, path);  // destination=RX, source=TX
	azimuth = AzimuthAngleBetweenSites(destination, source);
	distance = GreatCircleDistanceBetweenSiteLocations(destination, source);
	refangle = ElevationAngleBetweenSites(destination, source, digitalElevationModelWrapper, sphereRadius);
	b = GetSiteLocationElevation(destination, digitalElevationModelWrapper) + destination.altitude + sphereRadius;

	// Wavelength and path distance (great circle) in feet.

	if (fresnel_plot)
	{
		lambda = SPEED_OF_LIGHT_FEET_PER_SECOND / (itmParameters->referenceFrequency * 1e6);
		d = FEET_PER_MILE * path->distances[path->pathLength - 1];
	}

	if (normalized)
	{
		ed = GetSiteLocationElevation(destination, digitalElevationModelWrapper);
		es = GetSiteLocationElevation(source, digitalElevationModelWrapper);
		nb = -destination.altitude - ed;
		nm = (-source.altitude - es - nb) / (path->distances[path->pathLength - 1]);
	}

	char plotNameAndPath[335];
	sprintf_s(plotNameAndPath, _countof(plotNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "splat.gp");

	char profileNameAndPath[335];
	sprintf_s(profileNameAndPath, _countof(profileNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "profile.gp");

	char clutterNameAndPath[335];
	sprintf_s(clutterNameAndPath, _countof(clutterNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "clutter.gp");

	char referenceNameAndPath[335];
	sprintf_s(referenceNameAndPath, _countof(referenceNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "reference.gp");

	char curvatureNameAndPath[335];
	sprintf_s(curvatureNameAndPath, _countof(curvatureNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "curvature.gp");

	char fresnelNameAndPath[335];
	sprintf_s(fresnelNameAndPath, _countof(fresnelNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "fresnel.gp");

	char fresnelPtNameAndPath[335];
	sprintf_s(fresnelPtNameAndPath, _countof(fresnelPtNameAndPath), "%s%s", (reportSavePath[0] ? reportSavePath : ""), "fresnel_pt_6.gp");

	err = fopen_s(&fd, profileNameAndPath, "wb");

	if (groundClutterHeight > 0.0)
	{
		err = fopen_s(&fd1, clutterNameAndPath, "wb");
	}

	err = fopen_s(&fd2, referenceNameAndPath, "wb");
	err = fopen_s(&fd5, curvatureNameAndPath, "wb");

	if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
	{
		err = fopen_s(&fd3, fresnelNameAndPath, "wb");
		err = fopen_s(&fd4, fresnelPtNameAndPath, "wb");
	}

	for (x = 0; x < (path->pathLength - 1); x++)
	{
		remote.latitude = path->latitudes[x];
		remote.longitude = path->longitudes[x];
		remote.altitude = 0.0;

		terrain = GetSiteLocationElevation(remote, digitalElevationModelWrapper);

		if (x == 0)
		{
			terrain += destination.altitude;  // RX antenna spike
		}

		a = terrain + sphereRadius;
		cangle = FEET_PER_MILE * GreatCircleDistanceBetweenSiteLocations(destination, remote) / sphereRadius;
		c = b * sin(refangle * DEGREES_TO_RADIANS + HALF_PI) / sin(HALF_PI - refangle * DEGREES_TO_RADIANS - cangle);

		height = a - c;

		// Per Fink and Christiansen, Electronics
		// Engineers' Handbook, 1989:
		// 
		// H = sqrt(lamba * d1 * (d - d1)/d)
		// 
		// where H is the distance from the LOS
		// path to the first Fresnel zone boundary.

		if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
		{
			d1 = FEET_PER_MILE * path->distances[x];
			f_zone = -1.0 * sqrt(lambda * d1 * (d - d1) / d);
			fpt6_zone = f_zone * fresnelZoneClearanceRatio;
		}

		if (normalized)
		{
			r = -(nm * path->distances[x]) - nb;
			height += r;

			if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
			{
				f_zone += r;
				fpt6_zone += r;
			}
		}
		else
		{
			r = 0.0;
		}

		if (useMetricUnits)
		{
			fprintf(fd, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * height);

			if ((fd1 != NULL) && (x > 0) && (x < (path->pathLength - 2)))
			{
				fprintf(fd1, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * (terrain == 0.0 ? height : (height + groundClutterHeight)));
			}

			fprintf(fd2, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * r);
			fprintf(fd5, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * (height - terrain));
		}
		else
		{
			fprintf(fd, "%f\t%f\n", path->distances[x], height);

			if ((fd1 != NULL) && (x > 0) && (x < (path->pathLength - 2)))
			{
				fprintf(fd1, "%f\t%f\n", path->distances[x], (terrain == 0.0 ? height : (height + groundClutterHeight)));
			}

			fprintf(fd2, "%f\t%f\n", path->distances[x], r);
			fprintf(fd5, "%f\t%f\n", path->distances[x], height - terrain);
		}

		if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
		{
			if (useMetricUnits)
			{
				fprintf(fd3, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * f_zone);
				fprintf(fd4, "%f\t%f\n", KM_PER_MILE * path->distances[x], METERS_PER_FOOT * fpt6_zone);
			}
			else
			{
				fprintf(fd3, "%f\t%f\n", path->distances[x], f_zone);
				fprintf(fd4, "%f\t%f\n", path->distances[x], fpt6_zone);
			}

			if (f_zone < minheight)
			{
				minheight = f_zone;
			}
		}

		if ((height + groundClutterHeight) > maxheight)
		{
			maxheight = height + groundClutterHeight;
		}

		if (height < minheight)
		{
			minheight = height;
		}

		if (r > maxheight)
		{
			maxheight = r;
		}

		if (terrain < minterrain)
		{
			minterrain = terrain;
		}

		if ((height - terrain) < minearth)
		{
			minearth = height - terrain;
		}
	}

	if (normalized)
	{
		r = -(nm * path->distances[path->pathLength - 1]) - nb;
	}
	else
	{
		r = 0.0;
	}

	if (useMetricUnits)
	{
		fprintf(fd, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], METERS_PER_FOOT * r);
		fprintf(fd2, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], METERS_PER_FOOT * r);
	}
	else
	{
		fprintf(fd, "%f\t%f\n", path->distances[path->pathLength - 1], r);
		fprintf(fd2, "%f\t%f\n", path->distances[path->pathLength - 1], r);
	}

	if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
	{
		if (useMetricUnits)
		{
			fprintf(fd3, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], METERS_PER_FOOT * r);
			fprintf(fd4, "%f\t%f\n", KM_PER_MILE * path->distances[path->pathLength - 1], METERS_PER_FOOT * r);
		}
		else
		{
			fprintf(fd3, "%f\t%f\n", path->distances[path->pathLength - 1], r);
			fprintf(fd4, "%f\t%f\n", path->distances[path->pathLength - 1], r);
		}
	}

	if (r > maxheight)
	{
		maxheight = r;
	}

	if (r < minheight)
	{
		minheight = r;
	}

	fclose(fd);

	if (fd1 != NULL)
	{
		fclose(fd1);
	}

	fclose(fd2);
	fclose(fd5);

	if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
	{
		fclose(fd3);
		fclose(fd4);
	}

	if (name[0] == '.')
	{
		// Default filename and output file type

		err = strncpy_s(basename, _countof(basename), "profile\0", 8);
		err = strncpy_s(term, _countof(term), "png\0", 4);
		err = strncpy_s(ext, _countof(ext), "png\0", 4);
	}
	else
	{
		// Extract extension and terminal type from "name"

		ext[0] = 0;
		y = (int)strlen(name);
		err = strncpy_s(basename, _countof(basename), name, 254);

		for (x = y - 1; (x > 0) && (name[x] != '.'); x--);

		if (x > 0)  // Extension found
		{
			for (z = x + 1; (z <= y) && ((z - (x + 1)) < 10); z++)
			{
				ext[z - (x + 1)] = tolower(name[z]);
				term[z - (x + 1)] = name[z];
			}

			ext[z - (x + 1)] = 0;  // Ensure an ending 0
			term[z - (x + 1)] = 0;
			basename[x] = 0;
		}

		if (ext[0] == 0)	// No extension -- Default is png
		{
			err = strncpy_s(term, _countof(term), "png\0", 4);
			err = strncpy_s(ext, _countof(ext), "png\0", 4);
		}
	}

	// Either .ps or .postscript may be used
	// as an extension for postscript output.

	if (strncmp(term, "postscript", 10) == 0)
	{
		err = strncpy_s(ext, _countof(ext), "ps\0", 3);
	}
	else if (strncmp(ext, "ps", 2) == 0)
	{
		err = strncpy_s(term, _countof(term), "postscript enhanced color\0", 26);
	}

	dheight = maxheight - minheight;
	miny = minheight - 0.15 * dheight;
	maxy = maxheight + 0.05 * dheight;

	if (maxy < 20.0)
	{
		maxy = 20.0;
	}

	dheight = maxheight - minheight;
	min2y = miny - minterrain + 0.05 * dheight;

	if (minearth < min2y)
	{
		miny -= min2y - minearth + 0.05 * dheight;
		min2y = minearth - 0.05 * dheight;
	}

	max2y = min2y + maxy - miny;

	err = fopen_s(&fd, plotNameAndPath, "w");

	if (!err && fd != NULL)
	{
		fprintf(fd, "set grid\n");
		fprintf(fd, "set yrange [%2.3f to %2.3f]\n", (useMetricUnits ? miny * METERS_PER_FOOT : miny), (useMetricUnits ? maxy * METERS_PER_FOOT : maxy));
		fprintf(fd, "set y2range [%2.3f to %2.3f]\n", (useMetricUnits ? min2y * METERS_PER_FOOT : min2y), (useMetricUnits ? max2y * METERS_PER_FOOT : max2y));
		fprintf(fd, "set xrange [-0.5 to %2.3f]\n", (useMetricUnits ? KM_PER_MILE * rint(distance + 0.5) : rint(distance + 0.5)));
		fprintf(fd, "set encoding iso_8859_1\n");
		fprintf(fd, "set term %s\n", term);

		if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
		{
			fprintf(fd, "set title \"%s Path Profile Between %s and %s (%.2f%c azimuth)\\nWith First Fresnel Zone\"\n", APP_NAME, destination.name, source.name, azimuth, 176);
		}
		else
		{
			fprintf(fd, "set title \"%s Height Profile Between %s and %s (%.2f%c azimuth)\"\n", APP_NAME, destination.name, source.name, azimuth, 176);
		}

		if (useMetricUnits)
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f kilometers)\"\n", destination.name, source.name, KM_PER_MILE * GreatCircleDistanceBetweenSiteLocations(source, destination));
		}
		else
		{
			fprintf(fd, "set xlabel \"Distance Between %s and %s (%.2f miles)\"\n", destination.name, source.name, GreatCircleDistanceBetweenSiteLocations(source, destination));
		}

		if (normalized)
		{
			if (useMetricUnits)
			{
				fprintf(fd, "set ylabel \"Normalized Height Referenced To LOS Path Between\\n%s and %s (meters)\"\n", destination.name, source.name);
			}
			else
			{
				fprintf(fd, "set ylabel \"Normalized Height Referenced To LOS Path Between\\n%s and %s (feet)\"\n", destination.name, source.name);
			}
		}
		else
		{
			if (useMetricUnits)
			{
				fprintf(fd, "set ylabel \"Height Referenced To LOS Path Between\\n%s and %s (meters)\"\n", destination.name, source.name);
			}
			else
			{
				fprintf(fd, "set ylabel \"Height Referenced To LOS Path Between\\n%s and %s (feet)\"\n", destination.name, source.name);
			}
		}

		fprintf(fd, "set output \"%s.%s\"\n", basename, ext);

		if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
		{
			if (groundClutterHeight > 0.0)
			{
				if (useMetricUnits)
				{
					fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Ground Clutter (%.2f meters)\" with lines, \"%s\" title \"Line of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines, \"%s\" axes x1y1 title \"First Fresnel Zone (%.3f MHz)\" with lines, \"%s\" title \"%.0f%% of First Fresnel Zone\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight * METERS_PER_FOOT, referenceNameAndPath, curvatureNameAndPath, fresnelNameAndPath, itmParameters->referenceFrequency, fresnelPtNameAndPath, fresnelZoneClearanceRatio * 100.0);
				}
				else
				{
					fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Ground Clutter (%.2f feet)\" with lines, \"%s\" title \"Line of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines, \"%s\" axes x1y1 title \"First Fresnel Zone (%.3f MHz)\" with lines, \"%s\" title \"%.0f%% of First Fresnel Zone\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight, referenceNameAndPath, curvatureNameAndPath, fresnelNameAndPath, itmParameters->referenceFrequency, fresnelPtNameAndPath, fresnelZoneClearanceRatio * 100.0);
				}
			}
			else
			{
				fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Line of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines, \"%s\" axes x1y1 title \"First Fresnel Zone (%.3f MHz)\" with lines, \"%s\" title \"%.0f%% of First Fresnel Zone\" with lines\n", profileNameAndPath, referenceNameAndPath, curvatureNameAndPath, fresnelNameAndPath, itmParameters->referenceFrequency, fresnelPtNameAndPath, fresnelZoneClearanceRatio * 100.0);
			}
		}
		else
		{
			if (groundClutterHeight > 0.0)
			{
				if (useMetricUnits)
				{
					fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Ground Clutter (%.2f meters)\" with lines, \"%s\" title \"Line Of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight * METERS_PER_FOOT, referenceNameAndPath, curvatureNameAndPath);
				}
				else
				{
					fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Ground Clutter (%.2f feet)\" with lines, \"%s\" title \"Line Of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines\n", profileNameAndPath, clutterNameAndPath, groundClutterHeight, referenceNameAndPath, curvatureNameAndPath);
				}
			}
			else
			{
				fprintf(fd, "plot \"%s\" title \"Point-to-Point Profile\" with lines, \"%s\" title \"Line Of Sight Path\" with lines, \"%s\" axes x1y2 title \"Earth's Curvature Contour\" with lines\n", profileNameAndPath, referenceNameAndPath, curvatureNameAndPath);
			}
		}

		fclose(fd);
	}

	char gnuPlotAndSplat[335];
	sprintf_s(gnuPlotAndSplat, _countof(gnuPlotAndSplat), "gnuplot \"%s\"", plotNameAndPath);

	// Invokve gnuplot and run the splat.gp script.

	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	// Start the child process.

	bool gnuplotSuccess = CreateProcess(NULL, gnuPlotAndSplat, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);

	if (gnuplotSuccess == true)
	{
		// Wait until child process exits.
		WaitForSingleObject(pi.hProcess, INFINITE);

		// Close process and thread handles.
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);

		if (saveGnuPlotWorkingFiles == 0)
		{
			_unlink(plotNameAndPath);
			_unlink(profileNameAndPath);
			_unlink(referenceNameAndPath);
			_unlink(curvatureNameAndPath);

			if (fd1 != NULL)
			{
				_unlink(clutterNameAndPath);
			}

			if ((itmParameters->referenceFrequency >= MINIMUM_FREQUENCY) && (itmParameters->referenceFrequency <= MAXIMUM_FREQUENCY) && fresnel_plot)
			{
				_unlink(fresnelNameAndPath);
				_unlink(fresnelPtNameAndPath);
			}
		}

		fprintf(stdout, "\nHeight plot written to: \"%s.%s\"", basename, ext);
		fflush(stdout);
	}
	else
	{
		fprintf(stderr, "\n*** ERROR: Error occurred invoking gnuplot\n");
	}
}
